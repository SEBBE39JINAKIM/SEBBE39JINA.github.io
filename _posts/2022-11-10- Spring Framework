## Spring Framework 소개

### Framework이란?  

Frame은 어떤 대상의 큰 틀이나 외형적인 구조를 의미하는데 프로그래밍에서의 Frame 역시 비슷한 의미를 가지고 있다.  

따라서 소프트웨어 관점에서의 Framework는 우리가 어떤 애플리케이션을 만들기 위한 틀 혹은 구조를 제공한다고 생각하면 된다.  

**frame 단어가 사용된 예시**  

```html
<frameset cols="33%,*,33%">
    <frame name="left" src="/left_menu"/>
    <frame name="center" src="/context"/>
    <frame name="right" src="/right_menu"/>
</frameset>
```
웹의 초창기 시절에는 HTML 문서를 구성하는 태그 중에서 frame이라는 태그가 존재했다. frameset과 frame 태그를 이용해서 HTML 문서의 틀만 구성하고 있는 것을 볼 수 있다.  

**Framework의 의미**  

Java에서는 Collections Framework를 통해 의미를 찾아볼 수 있다.  

Java에서 자주 사용하는 Map이나 Set, List 등의 Collection들은 데이터를 저장하기 위해 널리 알려져 있는 자료구조를 바탕으로 비슷한 유형의 데이터들을 가공 및 처리하기 쉽도록 표준화 된 방법을 제공하는 클래스의 집합이다.  

그런데 왜 Java의 Collection에 Framework이라는 용어를 붙였을까?  

-> Java 클래스의 유형 중에서 기본적인 뼈대로만 구성되어 있는 것은 바로 추상 메서드만 정의되어 있는 인터페이스(Interface)다. 그리고 Java에서 Collection은 바로 Map, Set, List 같은 인터페이스와 그 인터페이스들을 구현한 구현체들의 집합인 것이다.  

**결론:** 프로그래밍 상에서의 Framework는 기본적으로 프로그래밍을 하기 위한 어떠한 틀이나 구조를 제공한다.  

**- Framework를 사용하는 장점**  

**효율적으로 코드를 작성할 수 있다.**  
기본 구조가 만들어져 있는 상황에서 코드를 작성하는것이 개발자가 애플리케이션의 핵심 로직을 개발하는 것에 집중할 수 있도록 해준다.  

**정해진 규약이 있어 애플리케이션을 효율적으로 관리할 수 있다.**  
우리가 사용하는 Framework의 규약에 맞게 코드를 작성하기 때문에, 유지보수가 필요한 경우 더 빠르고 쉽게 문제점을 파악해 수정할 수 있고, 내가 작업했던 코드를 다른사람이 수정할 경우에도 규약에 맞게 작성된 코드이기 떄문에, 빠르게 코드를 파악하고 수정하기 용이하다.  
= 유지보수 이외에도 비슷한 기능을 개발할때 코드의 재사용이 용이하고 기능의 확장또한 쉽게 확장이 가능하다.  

**- Framework를 사용하는 단점**  

**내가 사용하고자 하는 Framework에 대한 학습이 필요하다.**  
Spring의 경우 Java언어에 대한 이해도 필요하지만 추가로 Spring이라는 Framework에 대한 학습도 필요하다.  

**자유롭고 유연한 개발이 어렵다.**  
사용하는 Framework에 규약을 벗어나기가 어렵다. 이미 만들어진 애플리케이션에서 Framework를 변경하거나, 유연한 개발을 위해 Framework를 사용하지 않게 변경할 경우 많은 시간과 노력이 필요하다.  

### Framework와 Library의 차이  

> **소프트웨어 관점에서의 Library**  
>
Library는 애플리케이션을 개발하는 데 사용되는 일련의 데이터 및 프로그래밍 코드. 애플리케이션을 개발할 때 필요한 기능을 미리 구현해놓은 집합체라고 생각할 수 있다.


**Framework와 Library의 차이점**  

>**예시) 자동차**  
차체를 구성하는 Frame, 그리고 바퀴, 핸들 엔진과 같은 다양한 부품들이 모여서 하나의 자동차를 이룬다. 자동차를 구성하고 있는 요소에서 Framework는 자동차의 뼈대인 Frame을 의미하고, Library는 자동차에서 다양한 기능을 제공하는 부품(바퀴, 엔진, 라이트, 와이퍼등)을 의미한다.

자동차를 구매후, 부품을 교체할때 자동차를 새로 사지 않는이상 Frame은 쉽게 교체할 수 없다. 하지만 바퀴나 와이퍼, 라이트는 언제든지 쉽게 교체가 가능하다.  

📍 소프트웨어 관점에서도 한번 정해진 Framework를 교체하는일은 어렵지만, Library는 쉽게 교체가 가능하며 필요한 Library들을 선택적으로 사용할 수 있다.  
**(애플리케이션에 대한 제어권의 차이)**  

**Framework과 Library의 차이점을 이해하기 위한 예시 코드**  

```java
@SpringBootApplication
@RestController
@RequestMapping(path = "/v1/message")
public class Sample {
    @GetMapping
    public String getMessage() {  // Framework를 사용하는 부분
        String message = "hello world";
        return StringUtils.upperCase(message); // Library를 사용하는 부분
    }

    public static void main(String[] args) {
        SpringApplication.run(SampleApplication.class, args);
    }
}
```
**👉🏻 Library를 사용하는 부분**  
StringUtils 클래스는 Apache Commons Lang3 라이브러리의 유틸리티 클래스 중 하나인데 애플리케이션이 동작하는 중에 이 StringUtils 클래스의 `upperCase()` 메서드의 파라미터로 전달하는 문자열(message 변수)을 대문자로 변환하고 있다.  

개발자가 짜 놓은 코드내에서 필요한 기능이 있으면 해당 라이브러리를 호출해서 사용하는 것이 Library이다. 즉, 애플리케이션 흐름의 주도권이 개발자에게 있다.


**👉🏻 Framework를 사용하는 부분**  
애너테이션이나 `main()` 메서드 내의 `SpringApplication.run()` 메서드는 Spring Framework에서 지원하는 기능들인데 이러한 기능들은 라이브러리와는 다르게 코드 상에는 보이지 않는 많은 일들을 한다.  

`getMessage()` 메서드 내부의 코드처럼 개발자가 메서드내에 코드를 작성해두면, Spring Framework에서 개발자가 작성한 코드를 사용해서 애플리케이션의 흐름을 만들어낸다. 즉, 애플리케이션 흐름의 주도권이 개발자가 아닌 Framework에 있다.  

### Spring Framework이란?  

웹 애플리케이션 개발을 위한 Framework에는 Spring뿐만 아니라, Django, Express, Flask, Lalavel 등 다양한 Framework를 통해 개발이 가능하다. 각각 Framework마다 사용하는 언어도 다르고 개발 방법도 조금씩 달라지게 된다.  

**Spring Framework만의 장점**  

1. POJO(Plan Old Java Object)기반의 구성  
2. DI(Dependency Injection) 지원  
3. AOP(Aspect Oriented Programming, 관점지향 프로그래밍) 지원  
4. Java 언어를 사용함으로써 얻는 장점  

Spring Framework을 학습함으로 인해서 객체 지향 설계 원칙에 잘 맞는 재사용과 확장이 가능한 애플리케이션 개발 스킬을 향상시킬 수 있다는 것, 그리고 보다 나은 성능과 서비스의 안전성이 필요한 복잡한 **기업용 엔터프라이즈 시스템** 을 제대로 구축하기 위한 능력을 기를 수 있다.  

>**기업용 엔터프라이즈 시스템**  
>
기업의 업무(기업 자체 조직의 업무, 고객을 위한 서비스 등)를 처리해주는 시스템을 의미. 기업용 엔터프라이즈 시스템은 대량의 사용자 요청을 처리해야 하기 때문에 서버의 자원 효율성, 보안성, 시스템의 안전성이나 확장성 등을 충분히 고려해서 시스템을 구축하는 것이 일반적이다.  

### Spring Framework을 배워야 하는 이유  

**Spring Framework을 본격적으로 도입하기 전의 기술들 - 단계적 서술**

**1. JSP(Java Server Page)를 이용한 애플리케이션**  
초창기 Java 기반의 웹 애플리케이션 개발은 JSP를 통해 이루어졌다.  

JSP 개발 방식은 사용자에게 보여지는 View 페이지쪽 코드와 사용자의 요청을 처리하는 서버쪽 코드가 섞여있는 형태의 개발 방식이다. 쉽게 말하면 웹 브라우저를 통해서 사용자에게 보여지는 클라이언트 측 html/Javascript 코드와 사용자의 요청을 처리하는 서버 측 Java 코드가 뒤섞여 있는 방식이다.  

- **JSP 방식 예제코드**
```java
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<%@ taglib uri="http://java.sun.com/jsp/jstl/core" prefix="c"%>
<%@ taglib uri="http://java.sun.com/jsp/jstl/functions" prefix="fn" %>
<!-- (1) 시작 -->
<%
    request.setCharacterEncoding("UTF-8");
    response.setContentType("text/html;charset=UTF-8");

    System.out.println("Hello");

    String todoName = request.getParameter("todoName");
    String todoDate = request.getParameter("todoDate");

    ToDo.todoList.add(new ToDo(todoName, todoDate));

    RequestDispatcher dispatcher = request.getRequestDispatcher("/todo_model1.jsp");
    request.setAttribute("todoList", ToDo.todoList);

    dispatcher.forward(request, response);
%>
<!-- (1) 끝 -->
<html>
<head>
    <meta http-equiv="Content-Language" content="ko"/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>

    <title>TODO 등록</title>
    <style>
        #todoList {
            border: 1px solid #8F8F8F;
            width: 500px;
            border-collapse: collapse;
        }

        th, td {
            padding: 5px;
            border: 1px solid #8F8F8F;
        }
    </style>
    <script>
        function registerTodo(){
            var todoName = document.getElementById("todoName").value;
            var todoDate = document.getElementById("todoDate").value;

            if(!todoName){
                alert("할일을 입력해주세요..");
                return false;
            }
            if(!todoDate){
                alert("날짜를 입력해주세요.");
                return false;
            }

            var form = document.getElementById("todoForm");
            form.submit();

        }
    </script>
</head>
<body>
    <h3>TO DO 등록</h3>
    <div>
        <form id="todoForm" method="POST" action="/todo_model1.jsp">
            <input type="text" name="todoName" id="todoName" value=""/>
            <input type="date" name="todoDate" id="todoDate" value=""/>
            <input type="button" id="btnReg" value="등록" onclick="registerTodo()"/>
        </form>
    </div>
    <div>
        <h4>TO DO List</h4>
        <table id="todoList">
            <thead>
                <tr>
                    <td align="center">todo name</td><td align="center">todo date</td>
                </tr>
            </thead>
						<!-- (2) 시작 --->
            <tbody>
                <c:choose>
                    <c:when test="${fn:length(todoList) == 0}">
                        <tr>
                            <td align="center" colspan="2">할 일이 없습니다.</td>
                        </tr>
                    </c:when>
                    <c:otherwise>
                        <c:forEach items="${todoList}" var="todo">
                            <tr>
                                <td>${todo.todoName}</td><td align="center">${todo.todoDate}</td>
                            </tr>
                        </c:forEach>
                    </c:otherwise>
                </c:choose>
            </tbody>
						<!-- (2) 끝 -->
        </table>
    </div>
</body>
</html>
```
👉🏻 자신의 할일을 등록하는 화면과 등록한 할일을 목록으로 보여주는 화면을 포함한 간단한 로직.  

**JSP의 문제점**

코드 자체가 너무 길어서 가독성도 떨어지고, 복잡해 보인다.  

이 방식은 애플리케이션의 유지 보수 측면에서 최악의 방식이라고 볼 수 있다. 웹 디자이너와 html 퍼블리셔 그리고 자바스크립트 개발자 및 자바 개발자 간에 효율적으로 협업하는 것이 거의 불가능한 수준이다.

실제로 JSP 방식으로 개발 할 때에는 프론트엔드/백엔드 영역을 구분하지 않고 양쪽을 모두 개발하는 개발자들이 많았다.   

**2. 서블릿(Servlet)을 이용한 애플리케이션**  
Servlet은 클라이언트 웹 요청 처리에 특화된 Java 클래스의 일종.  

Spring을 사용한 웹 요청을 처리할때에도 내부적으로는 Servlet을 사용한다. 여기서 Servlet을 이용한다는 의미는 Servlet을 위한 Java 코드가 클라이언트 측 코드에서 분리되어 별도의 Java 클래스로 관리된다는 것을 의미한다.  

- **서블릿 방식 예제코드**  
```java
@WebServlet(name = "TodoServlet")
public class TodoServlet extends HttpServlet {
    // (1) Database를 대신한다.
    private List<ToDo> todoList;

    @Override
    public void init() throws ServletException {
        super.init();
        this.todoList = new ArrayList<>();
    }

		// (2)
    protected void doPost(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        request.setCharacterEncoding("UTF-8");
        response.setContentType("text/html;charset=UTF-8");

        String todoName = request.getParameter("todoName");
        String todoDate = request.getParameter("todoDate");

        todoList.add(new ToDo(todoName, todoDate));

        RequestDispatcher dispatcher = 
                request.getRequestDispatcher("/todo.jsp");
        request.setAttribute("todoList", todoList);

        dispatcher.forward(request, response);
    }

		// (3)
    protected void doGet(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        System.out.println("Hello");

        RequestDispatcher dispatcher = 
                request.getRequestDispatcher("/todo.jsp");
        dispatcher.forward(request, response);
    }
}
```
👉🏻 클라이언트 측의 JSP 코드에서 서버 측 Java 코드는 서블릿 클래스로 분리했기 때문에 클라이언트와 서버 간에 역할이 분리되었다고 볼 수 있다.  

하지만 역시 코드가 너무 길다. (2)의 경우, 클라이언트 측에서 등록할 할일 데이터를 전송하면 이 요청을 받아서 데이터 저장소에 등록해주는 역할을 하는데 데이터베이스 같은 별도의 저장소를 사용하지 않고, (1)과 같이 Java의 List에 추가를 했다.  

데이터를 가공하는 비즈니스 로직이 있는 것도 아니고, 가공된 데이터를 데이터베이스에 저장하는 등의 데이터 액세스 로직 역시 존재하지 않는데도 불구하고 코드 자체가 너무 길다.  

**3. Spring MVC를 이용한 애플리케이션**  

- **Spring MVC 방식 예제코드**  
```java
@Controller
public class ToDoController {
    @RequestMapping(value = "/todo", method = RequestMethod.POST)
    @ResponseBody
    public List<ToDo> todo(@RequestParam("todoName")String todoName,
                               @RequestParam("todoDate")String todoDate) {
        ToDo.todoList.add(new ToDo(todoName, todoDate));
        return ToDo.todoList;
    }

    @RequestMapping(value = "/todo", method = RequestMethod.GET)
    @ResponseBody
    public List<ToDo> todoList() {
        return ToDo.todoList;
    }
}
```
👉🏻 코드 자체가 간결해졌다. 서블릿 방식의 코드에서는 클라이언트의 요청에 담긴 데이터를 꺼내오는 작업을 개발자가 직접 코드로 작성 해야되고, 캐릭터셋도 지정 해주어야 하는데 반면에 Spring MVC 방식의 코드에서는 눈에 보이지 않지만 그런 작업들을 Spring에서 알아서 처리해줬다.  

그런데 Spring의 이런 편리함과 간결함에도 불구하고 Spring 기반의 애플리케이션의 기본 구조를 잡는 설정 작업이 여전히 불편하다는 단점이 존재했었다.  

- **Spring MVC 설정 파일 예제코드**
```html
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">
    <context-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>/WEB-INF/spring-config/applicationContext.xml</param-value>
    </context-param>
    <listener>
        <listener-class>
            org.springframework.web.context.ContextLoaderListener
        </listener-class>
    </listener>
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>
            org.springframework.web.servlet.DispatcherServlet
        </servlet-class>
        <init-param>
            <param-name>contextConfigLocation</param-name>
            <param-value>/WEB-INF/spring-config/dispatcher-servlet.xml</param-value>
        </init-param>
        <load-on-startup>1</load-on-startup>
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
    <filter>
        <filter-name>CORSFilter</filter-name>
        <filter-class>com.codestates.filter.CORSFilter</filter-class>
    </filter>
    <filter-mapping>
        <filter-name>CORSFilter</filter-name>
        <url-pattern>/*</url-pattern>
    </filter-mapping>

</web-app>
```
👉🏻 Spring MVC의 설정이 너무 복잡하다.  

**4. Spring Boot을 이용한 애플리케이션**  

- **Spring Boot 기반의 예제코드**
```java
@RestController
public class TodoController {
    private TodoRepository todoRepository;

    @Autowired
    TodoController(TodoRepository todoRepository) {
        this.todoRepository = todoRepository;
    }

    @PostMapping(value = "/todo/register")
    @ResponseBody
    public Todo register(Todo todo){ // (1)
        todoRepository.save(todo); // (2)
        return todo;
    }

    @GetMapping(value = "/todo/list")
    @ResponseBody
    public List<Todo> getTodoList(){
        return todoRepository.findAll(); // (3)
    }
}
```
👉🏻 Spring MVC 기반의 코드를 Spring Boot 기반에서 더 개선한 모습이다. 데이터를 실제로 저장하는 기능을 추가했는데도 불구하고 코드의 길이는 크게 바뀐 것이 없고, 오히려 더 깔끔해졌다.  

이번에는 클라이언트 측에서 전달한 요청 데이터를 (1)과 같이 Todo라는 클래스에 담아서 한번에 전달 받을 수 있도록 했다. 요청 데이터가 Todo 객체로 변경되는 것은 Spring이 알아서 해준다.  

그리고 이 전 방식까지는 클라이언트가 전달한 요청 데이터를 테스트 목적으로 단순히 List에 담았는데 이번에는 (2), (3)과 같이 데이터베이스에 저장해서 데이터 액세스 처리까지 하도록 했다.  

- **Spring Boot 구성 파일 예제코드**
```
spring.h2.console.enabled=true
spring.h2.console.path=/console
spring.jpa.generate-ddl=true
spring.jpa.show-sql=true
```
👉🏻 Spring MVC 방식에서 겪어야 했던 설정의 복잡함을 찾아볼 수 없다. 심지어 데이터베이스를 연동하지 않았다면 4줄의 코드도 안 필요하다.  

Spring의 복잡한 설정 작업마저도 Spring이 대신 처리를 해주기 때문에 개발자는 애플리케이션의 핵심 비즈니스 로직에만 집중할 수 있다.   

-----
## Spring Framework의 특징

### POJO(Plain Old Java Object)  

**PO** (Java로 생성하는 순수한 객체) + **JO** (Java = 객체지향 프로그래밍)  

**POJO 프로그래밍이란?**  

POJO를 이용해서 프로그래밍 코드를 작성하는 것을 의미한다. 하지만 순수 자바 객체만을 사용해서 프로그래밍 코드를 작성한다고 해서 POJO 프로그래밍이라고 볼 수는 없다.  

**- POJO 프로그래밍의 두 가지 규칙**  

**1. Java나 Java의 스펙(사양)에 정의된 것 이외에는 다른 기술이나 규약에 얽매이지 않아야 한다.**  
```java
// getter, setter만 가지고 있는 예

public class Member {
  private String name;
  private String password;

  public String getName() {
    return userName;
  }

  public void setName(String name) {
  	this.name = name;
  }

  public String getPassword() {
  	return password;
  }

  public void setPassword(String password) {
  	this.password = password;
  }
}
```

위 코드는 자바에서 제공하는 기능만 사용하여 getter, setter만 가지고 있다. Java 언어 이외에 특정한 기술에 종속되어 있지 않은 순수한 객체이기 때문에 POJO라고 부를 수 있다.  

```java
// 특정 기술에 종속적인 예

public class MessageForm extends ActionForm{ // Struts를 사용하기 위해서 ActionForm을 상속.
	
	String message;

	public String getMessage() {
		return message;
	}

	public void setMessage(String message) {
		this.message = message;
	}
	
}

public class MessageAction extends Action{ // Struts 기술의 Action 클래스를 상속 받고 있다.
	
	public ActionForward execute(ActionMapping mapping, ActionForm form,
		HttpServletRequest request, HttpServletResponse response)
        throws Exception {
		
		MessageForm messageForm = (MessageForm) form;
		messageForm .setMessage("Hello World");
		
		return mapping.findForward("success");
	}
	
}
```

ActionForm 클래스는 과거에 Struts라는 웹 프레임워크에서 지원하는 클래스이다.  

특정 기술을 상속 해서 코드를 작성하면 나중에 애플리케이션의 요구사항이 변경되서 다른 기술로 변경할때 Struts의 클래스를 명시적으로 사용했던 부분을 일일이 제거하거나 수정해야한다.  

그리고, Java는 다중 상속을 지원하지 않기 때문에 ‘extends’ 키워드를 사용해서 한 번 상속을 하게되면 상위 클래스를 상속받아서 하위 클래스를 확장하는 객체지향 설계 기법을 적용하기 어려워진다.  


**2. 특정 환경에 종속적이지 않아야 한다.**  
**예시)** 서블릿(Servlet) 기반의 웹 애플리케이션을 실행 시키는 서블릿 컨테이너인 아파치 톰캣(Apache Tomcat)  

순수 Java로 작성한 애플리케이션 코드내에서 Tomcat이 지원하는 API를 직접 가져다가 사용한다고 가정한다.  

그런데 만약 시스템의 요구 사항이 변경되어서 Tomcat말고 제티(Zetty)라는 다른 Servlet Container를 사용하게 된다면?  

-> 애플리케이션 코드에서 사용하고 있는 Tomcat API 코드들을 모두 걷어내고 Zetty로 수정하든가 최악의 경우, 애플리케이션을 전부 뜯어 고쳐야될지도 모른다.   

**POJO 프로그래밍이 필요한 이유**  

- 특정 환경이나 기술에 종속적이지 않으면 재사용 가능하고, 확장 가능한 유연한 코드를 작성할 수 있다.  
- 저수준 레벨의 기술과 환경에 종속적인 코드를 애플리케이션 코드에서 제거 함으로써 코드가 깔끔해진다.  
- 코드가 깔끔해지기 때문에 디버깅하기도 상대적으로 쉽다.  
- 특정 기술이나 환경에 종속적이지 않기 때문에 테스트 역시 단순해진다.  
- **객체지향적인 설계를 제한없이 적용할 수 있다.**   

### POJO와 Spring Framework의 관계  

Spring은 POJO 프로그래밍을 지향하는 Framework이다.  

Spring Framework를 사용하기 전에는 원하는 특정한 기술이 있으면 해당 기술을 직접적으로 사용하는 객체를 만들어 사용했다. 다만 프로젝트가 커지고 필요한 기술들이 늘어나며 특정 기술과 환경에 종속되는 경우가 자주 발생하여 작성된 코드의 유지/보수가 어렵고 특정 클래스를 상속받게 되어 기능의 확장이 어려운 경우도 많이 생겼다. 좋은 객체지향 설계를 할 수 있는 Java언어를 사용하면서도 결국 객체지향 설계 본질을 잃어버리는 문제점들을 해결하고자 POJO라는 개념이 등장하게 되었다.  

최대한 다른 환경이나 기술에 종속적이지 않도록 하기 위한 POJO 프로그래밍 코드를 작성하기 위해서 Spring에서는 세가지 기술(IoC/DI, AOP, PSA)을 지원하고 있다.    

-----
## IoC(Inversion of Control)  

> **애플리케이션 흐름의 주도권을 Spring이 갖는다.**

Framework과 Library의 차이점에서 언급된 애플리케이션 흐름의 주도권이 뒤바뀐 것을 IoC(Inversion of Control)라고 한다.  

**Java 콘솔 애플리케이션의 일반적인 제어권**  

```java
// Java 코드만으로 메시지를 콘솔에 출력
public class Example {
    public static void main(String[] args) {
        System.out.println("Hello IoC!");
    }
}
```
Java 콘솔 애플리케이션을 실행하려면 main() 메서드가 있어야 한다.  
main() 메서드가 호출 되고 난 다음에 System 클래스를 통해서 static 멤버 변수인 out의 println()을 호출한다.  

**Java 웹 애플리케이션에서 IoC가 적용되는 예**  

- 서블릿 컨테이너의 서블릿 호출 예  
![](https://velog.velcdn.com/images/wlsk124/post/187afcbd-e38f-44bd-abe7-bccfe5ecaa23/image.png)  

Java 콘솔 애플리케이션의 경우 main() 메서드가 종료되면 애플리케이션의 실행이 종료되지만, 웹에서 동작하는 애플리케이션의 경우 클라이언트가 외부에서 접속해서 사용하는 서비스이기 때문에 main() 메서드가 종료되지 않아야 한다.  

그런데 서블릿 컨테이너에는 서블릿 사양(Specification)에 맞게 작성된 서블릿 클래스만 존재하지 별도의 main() 메서드가 존재하지 않기 때문에 서블릿 컨테이너의 경우, 클라이언트의 요청이 들어올 때마다 서블릿 컨테이너 내의 컨테이너 로직(service() 메서드)이 서블릿을 직접 실행시켜 준다.  
-> main() 메서드가 필요없다.  

📍 main() 메서드처럼 애플리케이션이 시작되는 지점을 **엔트리 포인트(Entry point)** 라고도 부른다.  

이 경우, 서블릿 컨테이너가 서블릿을 제어하고 있기 때문에 애플리케이션의 주도권은 서블릿 컨테이너에 있다.  

**-> 서블릿과 웹 애플리케이션 간에 IoC(제어의 역전)의 개념이 적용됨.**  

-----
## DI(Dependency Injection)  

>**Dependency(의존하는 또는 종속되는) + Injection(주입) = DI(의존성 주입)**

**What - 의존성 주입은 무엇일까?**  
객체지향 프로그래밍에서 의존성이라고 하면 대부분 객체 간의 의존성을 의미한다.  

만약 A, B 두 개의 클래스 파일을 만들어서 A 클래스에서 B클래스의 기능을 사용하기 위해 B 클래스에 구현되어 있는 어떤 메서드를 호출한다면, ‘A클래스는 B클래스에 의존한다’라고 한다.  

**👉🏻 클래스 간의 의존 관계 성립 예시**  

![](https://velog.velcdn.com/images/wlsk124/post/ac7c8ad2-c05f-458e-8f3c-9bdf95cbb0ae/image.png)  

MenuController클래스는 클라이언트의 요청을 받는 엔드포인트(Endpoint) 역할을 하고, MenuService클래스는 MenuController클래스가 전달 받은 클라이언트의 요청을 처리하는 역할을 한다. MenuController 클래스는 메뉴판에 표시되는 메뉴 목록을 조회하기 위해서 MenuService의 기능을 사용하고 있다. Java의 객체 생성 방법인 new 키워드를 사용해서 MenuService 클래스의 객체를 생성한 후, MenuService의 getMenuList() 메서드를 호출하고 있다.    

📍 클라이언트 측면에서 서버의 엔드포인트(Endpoint)란 클라이언트가 서버의 자원(리소스, Resource)을 이용하기 위한 끝 지점을 의미한다.   

-> 클래스 끼리는 사용하고자 하는 클래스의 객체를 생성해서 참조하게 되면 의존 관계가 성립하게 된다.  

**👉🏻 클래스 간의 의존성 주입 예시**  

두 클래스 간에 의존 관계는 성립 되었지만, 의존성 주입은 이루어지지 않았다.  
![](https://velog.velcdn.com/images/wlsk124/post/360fa7e2-7ea7-4131-9cd5-b0c862076924/image.png)  

MenuController 생성자로 MenuService의 객체를 전달 받고 있다.  
-> 생성자를 통해서 어떤 클래스의 객체를 전달 받는 것이 `의존성 주입` 이다.  

생성자 뿐만 아니라 다른 방식으로도 의존성 주입이 가능하지만, 일반적으로는 생성자를 통한 의존관계 주입을 사용한다. 생성자를 통해 의존성을 주입하게 되면, 실제로 스프링에서 의존성 주입을 도와주고, 이 방법을 스프링에서 공식적으로 추천한다.  

**Why - 의존성 주입은 왜 필요할까?**  
객체지향 언어인 Java에서 생성자를 통해 객체를 전달하는 의존성 주입이 필요한 건 당연한 일이다. 그런데 의존성 주입을 사용할 때, 현재의 클래스 내부에서 외부 클래스의 객체를 생성하기 위한 new 키워드를 쓸지 말지 여부를 생각해야한다.  

일반적으로 Java에서 new 키워드를 사용해서 객체를 생성하는데, Reflection이라는 기법을 이용해서 Runtime시에 객체를 동적으로 생성할 수 있는 방법도 있다.  

그런데 애플리케이션 코드 내부에서 직접적으로 new 키워드를 사용할 경우 객체지향 설계의 관점에서 중요한 문제가 발생할 수 있다.  

**👉🏻 객체지향 설계의 관점에서 문제 예시**  

>**👩🏻‍💻 프론트엔드** - 메뉴 목록 화면에 표시할 데이터를 API로 통신하고 싶은데 메뉴 목록 데이터 조회 API 사용 가능할까요?  
>
**🧑🏻‍💻 백엔드 개발자** - API 틀만 구성한 상태인데 스텁(Stub)으로 제공해도 될까요?  
>
**👩🏻‍💻 프론트엔드** - 네, API 통신 잘 되는지랑 화면 구성이 괜찮은지 정도만 확인 할꺼라서 Stub으로 해주셔도 될 것 같아요.   

스텁(Stub)은 메서드 호출시 미리 준비된 데이터를 응답하는 것으로, 고정된 데이터이기 때문에 몇 번을 호출해도 동일한 데이터를 리턴한다. 여러번 호출해도 동일한 데이터를 리턴하는 것을 `멱등성(idempotent)을 가진다` 라고 한다.   

![](https://velog.velcdn.com/images/wlsk124/post/67152743-29b7-4729-b6a6-7a0f3dfe55d7/image.png)  

MenuServiceStub 클래스를 보면 getMenuList()에 Stub 데이터로 채워져 있다. 그런데 MenuServiceStub 클래스를 사용하려면 MenuService 클래스를 의존하고 있는 CafeClient와 MenuController에서 MenuService 를 MenuServiceStub 클래스로 불가피하게 변경해야 되는 상황이 발생한다. 만약 MenuServiceStub 클래스를 사용할 대상이 수십, 수백군데라면 불필요한 비용이 발생하게 된다.  

이처럼 new 키워드를 사용해서 의존 객체를 생성할 때, 클래스들 간에 `강하게 결합(Tight Coupling)되어 있다` 라고 한다.  

**-> 애플리케이션의 요구사항은 언제든 변할 수 있기 때문에 의존성 주입을 하더라도 클래스들 간의 느슨한 결합(Loose Coupling)이 필요하다.**  

**How - 느슨한 의존성 주입은 어떻게 할까?**  
Java에서 클래스들 간의 관계를 느슨하게 만드는 대표적인 방법은 인터페이스(Interface)를 사용하는 것이다. 어떤 클래스가 인터페이스 같이 일반화된 구성 요소에 의존하고 있을 때, 클래스들 간에 느슨하게 결합(Loose Coupling)되어 있다고 한다.    

![](https://velog.velcdn.com/images/wlsk124/post/43be0935-1c07-4715-96d8-78362ccd53ca/image.png)  

MenuController가 생성자로 MenuServiceStub 클래스를 주입 받았지만 여기서는 주입 받은 대상이 MenuService 인터페이스이기 때문에 MenuService 인터페이스의 구현 클래스이면 어떤 클래스도 전부 주입을 받을 수 있다.  

(1)에서 new 로 MenuServiceStub 클래스의 객체를 생성해서 MenuService 인터페이스에 할당한다. 업캐스팅을 통한 의존성 주입으로 인해 MenuController와 MenuService는 느슨한 결합 관계를 유지하게 되었다.  

📍 업캐스팅(Upcasting) - 인터페이스 타입의 변수에 그 인터페이스의 구현 객체를 할당.  

클래스들 간의 관계를 느슨하게 만들기 위해서는 `new 키워드`를 사용하지 않아야 되는데, CafeClient 클래스의 (1)은 MenuServiceStub의 객체와 MenuController 객체를 생성하기위해 new를 사용하고 있다.  

**Who - Spring 기반 애플리케이션에서는 의존성 주입을 누가 해줄까?**  

![](https://velog.velcdn.com/images/wlsk124/post/d78591e3-7975-4510-a7e6-218383a9a8e4/image.png)  

CafeClient 클래스에 MenuServiceStub 과 MenuController 객체를 생성하기 위해 `new 키워드`를 사용했었는데 위 사진 속 (1)과 같이 Spring에서 지원하는 API가 대신 의존성 주입을 하고 있다.  

> **문제점**  
POJO 프로그래밍을 위한 규칙 중에 하나가 ‘다른 기술이나 규약에 얽매이지 않아야한다’인데 (1)은 Spring Framework에 해당하는 코드가 애플리케이션 코드에 직접적으로 나왔다. - 좋은 개발 방식이 아니다.  
>
-> Spring을 이용한 DI(의존성 주입)의 예를 보여주기 위해 사용한 코드.


new 키워드를 없앤 방법  
-> `Config 클래스`  

**Config 클래스의 역할**   
Config 클래스에 정의해둔 MenuController 객체를 Spring의 도움을 받아 CafeClient클래스에게 제공 하고 있다.  

Config 클래스는 단순한 클래스가 아니라 Spring Framework의 영역에 해당하고 이 Config 클래스가 실제 애플리케이션의 핵심 로직에 관여하지 않는다. (Spring Framework의 영역)   

### 스프링 컨테이너(Spring Container)  

>**스프링 프레임워크의 핵심 컴포넌트.**  
스프링 컨테이너는 내부에 존재하는 애플리케이션 빈의 생명주기를 관리한다.  
-> Bean 생성, 관리, 제거 등의 역할을 담당.    


**What - 스프링 컨테이너는 무엇일까?**  
![](https://velog.velcdn.com/images/wlsk124/post/ccff74b1-b9a3-4661-9d31-609009eac8b5/image.png)  

- 스프링 컨테이너는 `XML, 애너테이션 기반의 자바 설정 클래스`로 만들 수 있다.  
- 빈의 인스턴스화, 구성, 전체 생명 주기 및 제거까지 처리한다.  
	- 개발자가 정의한 Bean을 객체로 만들어 관리하고 필요로 할 때 제공한다.
- 스프링 컨테이너를 통해 원하는 만큼 많은 객체를 가질 수 있다.  
- 의존성 주입을 통해 애플리케이션의 컴포넌트를 관리한다.   
	- 서로 다른 빈을 연결해 애플리케이션의 빈을 연결하는 역할을 한다.  
	- 개발자는 모듈 간에 의존 및 결합으로 인해 발생하는 문제로부터 자유로울 수 있다.  
	- 메서드가 언제, 어디서 호출되어야 하는지, 메서드를 호출하기 위해 필요한 매개 변수를 준비해서 전달하지 않는다.  

**Why - 스프링 컨테이너는 왜 사용할까?**  


객체를 사용하기 위해서 new 생성자를 써야 했다. 애플리케이션에서 이러한 객체가 무수히 많이 존재하고 서로 참조하게 되어있었는데, 서로 참조가 심할수록 의존성이 높다고 표현한다. 낮은 결합도와 높은 캡슐화가 객체지향프로그래밍의 핵심인데 높은 의존성은 이를 지키지 못한다.  

-> **그래서 객체 간의 의존성을 낮추기 위해 Spring 컨테이너를 사용한다.**  

>**📍 문제점 및 Spring 컨테이너가 해결법이 되는 이유**  
기존의 방식은 새로운 정책이 생기면 변경 사항들을 수작업으로 수정해야했다. 점점 서비스의 코드가 거대해질 경우 의존도는 높아졌을 것이고 그에 따른 코드의 변경도 많이 필요할 것이다.  
>
**하지만 스프링 컨테이너를 사용하면서 구현 클래스에 있는 의존을 제거하고 인터페이스에만 의존하도록 설계할 수 있다.**  

**How - 스프링 컨테이너의 생성 과정은 어떻게 될까?**  
주로 사용하게 되는 설정 방식은 Java 기반의 애너테이션 기반 설정이지만, 기존에 사용하던 XML 방식에 대해서도 이해 해야한다.  
![](https://velog.velcdn.com/images/wlsk124/post/6ac0a973-f2c3-47ab-8bad-6a199560eb59/image.png)  

- 스프링 컨테이너는 `Configuration Metadata`를 사용한다.   
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해 스프링 빈 등록.  
- new AnnotationConfigApplicationContext(`구성정보.class`)로 스프링에 있는 @Bean의 메서드를 등록한다.  
- [애너테이션 기반의 자바 설정 클래스로 Spring을 만드는 것을 의미한다.](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config)

```java
// Spring Container 생성
ApplicationContext applicationContext = new AnnotationConfigApplicationContext(DependencyConfig.class);
```

```java
// XML 기반 구성 메타데이터의 기본 구조
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://www.springframework.org/schema/beans
        https://www.springframework.org/schema/beans/spring-beans.xsd">
        
    <bean id="..." class="...">  
        <!-- collaborators and configuration for this bean go here -->
     </bean>
        
     <bean id="..." class="...">
         <!-- collaborators and configuration for this bean go here -->
     </bean>
        
     <!-- more bean definitions go here -->
        
</beans>
```

- **&#60;beans /&#62;** 에 필요한 값들을 설정. 
- **&#60;bean id=”...”&#62;** : 빈 정의를 식별하는데 사용되는 문자열.  
- **&#60;bean class=”...”&#62;** : Bean의 유형을 정의하고 클래스 이름을 사용.  


**스프링 컨테이너를 만드는 방법 - `ApplicationContext 인터페이스` 의 구현체**  

- DependencyConfig.class 등의 구성정보를 지정해서 스프링 컨테이너를 생성.  
- DependencyConfig의 구성정보를 통해 스프링 컨테이너는 객체를 생성하게 된다.  
- 애플리케이션 클래스는 구성 메타데이터와 결합되어 ApplicationContext 생성 및 초기화된 후 완전히 구성되고 실행 가능한 시스템 또는 애플리케이션을 갖게 된다.  

**스프링 빈 조회에서 상속관계가 있을 시 부모타입으로 조회하면 자식 타입도 함께 조회**  

- 모든 자바 객체의 최고 부모인 object타입으로 조회하면 모든 스프링 빈을 조회한다.

**ApplicationContext 인터페이스 구현체 확인법**  
Mac에서 Cmd + O → 클래스에서 `ApplicationContext` 검색  
![](https://velog.velcdn.com/images/wlsk124/post/3024c2aa-2d9f-46f3-adbe-031c77448175/image.png)  

가장 첫번째 파일인 ApplicationContext 인터페이스를 구현한 하위 클래스들이 나오는 걸 확인할 수 있다.  

**📍 스프링 컨테이너의 종류**    
파라미터로 넘어온 설정 클래스 정보를 참고해서 빈의 생성, 관계 설정 등의 제어작업을 총괄하는 컨테이너.  

**BeanFactory**  
- 스프링 컨테이너의 최상위 인터페이스.  
- 빈을 등록하고 생성하고 조회하고 돌려주는 등 빈을 관리하는 역할.
- getBean() 메소드를 통해 빈을 인스턴스화할 수 있다.
- @Bean이 붙은 메서드의 명을 스프링 빈의 이름으로 사용해 빈 등록을 한다.

**ApplicationContext**  
- BeanFactory의 기능을 상속받아 제공.
- 빈을 관리하고 검색하는 기능을 BeanFactory가 제공, 그 외 **부가기능**을 제공.
>**부가 기능**  
>
**MessageSource**: 메세지 다국화를 위한 인터페이스
**EnvironmentCapable**: 개발, 운영 등 환경변수 등으로 나눠 처리하고, 애플리케이션 구동 시 필요한 정보들을 관리하기 위한 인터페이스
**ApplicationEventPublisher**: 이벤트 관련 기능을 제공하는 인터페이스
**ResourceLoader**: 파일, 클래스 패스, 외부 등 리소스를 편리하게 조회  

**컨테이너 인스턴스화**  
ApplicationContext 생성자에 제공된 위치 경로 또는 경로는 컨테이너가 로컬 파일 시스템, Java CLASSPATH 등과 같은 다양한 **외부 리소스로부터 구성 메타데이터를 로드할 수 있도록 하는 리소스 문자열**.   

```java
// Annotation
ApplicationContext context = new AnnotationConfigApplicationContext(DependencyConfig.class);

// XML
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");
```

### 빈(Bean)  

>**스프링 컨테이너에 의해 관리되는 재사용 소프트웨어 컴포넌트.**  
Spring 컨테이너가 관리하는 자바 객체를 의미하며, 하나 이상의 빈을 관리한다.  

- 인스턴스화된 객체를 의미.  
- 스프링 컨테이너에 등록된 객체를 스프링 빈이라고 한다.   
- @Bean이 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다.  
- 클래스의 등록정보, 게터/세터 메서드를 포함한다.  
- 컨테이너에 사용되는 설정 메타데이터로 생성된다.  
- 설정 메타데이터  
	- XML 또는 자바 애너테이션, 자바 코드로 표현.
	- 컨테이너의 명령과 인스턴스화, 설정, 조립할 객체를 정의.  

**bean 접근 방법**  
`ApplicationContext` 사용하여 bean 정의를 읽고 액세스할 수 있다.  

```java
// create and configure beans
ApplicationContext context = new ClassPathXmlApplicationContext("services.xml", "daos.xml");

// retrieve configured instance
PetStoreService service = context.getBean("repository", repository.class);

// use configured instance
List<String> userList = service.getUsernameList();
```
`getBean()`을 사용해 bean의 인스턴스를 가져올 수 있다.  
`ApplicationContext` 인터페이스는 bean을 가져오는 몇 가지 방법들이 있다.  

**BeanDefinition**  
Bean은 [BeanDefinition(빈 설정 메타정보)](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/BeanDefinition.html)으로 정의되고 BeanDefinition에 따라서 활용하는 방법이 달라지게 된다.  

- 속성에 따라 컨테이너가 Bean을 어떻게 생성하고 관리할지 결정.
- `@Bean` or `<bean>` 당 각 1개씩 메타 정보 생성.
- Spring이 설정 메타정보를 BeanDefinition 인터페이스를 통해 관리하기 때문에 컨테이너 설정을 XML, Java로 할 수 있다.

**빈 스코프(Bean Scope)**  

- 특정 bean 정의에서 생성된 개체에 연결할 다양한 의존성 및 구성 값뿐만 아니라 특정 bean 정의에서 생성된 개체의 범위도 제어할 수 있다.
- Spring Framework는 6개의 범위를 지원하며, 그 중 4개는 `ApplicationContext`를 사용하는 경우에만 사용할 수 있다.
- bean은 여러 범위 중 하나에 배치되도록 정의할 수 있다.
- 구성을 통해 생성하는 개체의 범위를 선택할 수 있기 때문에 강력하고 유연하다.
- 사용자 정의 범위를 생성할 수도 있다.


|Scope	|Description|
|:----:|---|
|singleton (Default)|각 Spring 컨테이너에 대한 단일 객체 인스턴스에 대한 단일 bean definition의 범위를 지정.|
|prototype|스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는 매우 짧은 범위의 스코프.|
|request|웹 요청이 들어오고 나갈때 까지 유지되는 스코프.|
|session|웹 세션이 생성되고 종료될 때 까지 유지되는 스코프.|
|application|웹의 서블릿 컨텍스와 같은 범위로 유지되는 스코프.
|websocket|단일 bean definition 범위를 WebSocket의 라이프사이클까지 확장.  **Spring ApplicationContext** 의 컨텍스트에서만 유효하다.


**싱글톤(singleton) 스코프**  
- 클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴.    
- 스프링 컨테이너의 시작과 함께 생성되어서 스프링 컨테이너가 종료될 때 까지 유지된다.  
- 싱글톤 빈의 하나의 공유 인스턴스만 관리하게 된다.  
	- private 생성자를 사용해 외부에서 임의로 new를 사용하지 못하도록 막아야 한다.  
- 해당 bean definition와 일치하는 ID 또는 ID를 가진 빈에 대한 모든 요청은 스프링 컨테이너에서 해당 특정 빈 인스턴스를 반환한다.  
- 스프링 컨테이너 종료시 소멸 메서드도 자동으로 실행된다.  
- 단일 인스턴스는 싱글톤 빈의 캐시에 저장됩니다.
- 싱글톤 스코프의 스프링 빈은 여러번 호출해도 같은 인스턴스 참조 주소값을 가진다.  

**- 작동 방식**  

![](https://velog.velcdn.com/images/wlsk124/post/da73d53a-12d7-41f0-be96-e66678d3c358/image.png)  


**싱글톤 패턴의 문제점**  

- 싱글톤 패턴을 구현하는 코드 자체가 많다.  
- 의존관계상 클라이언트가 구체 클래스에 의존한다.  
- 지정해서 가져오기 때문에 테스트하기 어렵습니다.  
- private 생성자를 사용하여 자식 클래스를 만들기 어렵기 때문에 유연성이 떨어진다.  
- 속성 공유  
	- 멀티쓰레드 환경에서 싱글톤 객체의 속성은 여러 쓰레드에 의해 바뀔 수 있다.  
    - A 쓰레드에선 속성 값을 x로 바꾸고 출력하는 과정에서 B 쓰레드가 속성 값을 y로 바꾸면 쓰레드 A에선 예상하지 못한 값이 나올 수 있다.  
(1개의 인스턴스에서 속성 값을 공유하기 때문에 발생하는 문제점.)  
	- 가급적 읽기만 가능해야 한다.  
- Application 초기 구동 시 인스턴스 생성  
	- 싱글톤 빈은 기본적으로 애플리케이션 구동 시 생성되므로 싱글톤 빈이 많을 수록 구동 시간이 증가할 수 있다.   

**싱글톤 패턴 문제 해결책 -> 싱글톤 컨테이너**  

- 객체 인스턴스를 싱글톤으로 관리한다.
- 스프링 컨테이너는 싱글톤 컨테이너 역할을 한다.
- 싱글톤 객체로 생성하고 관리하는 기능이 싱글톤 레지스트리이다.
- 싱글턴 패턴의 모든 단점을 해결하고 객체를 싱글톤으로 유지할 수 있다.  

**싱글톤 방식의 주의점**  
여러 클라이언트가 하나의 객체 인스턴스를 공유하기 때문에 무상태로 설계해야 한다.  
- 특정 클라이언트가 값을 변경할 수 있으면 안된다.  
- 읽기만 가능해야 한다.  
- 스프링 빈의 공유 값을 설정하면 장애가 발생할 수 밖에 없다.  

### Java 기반 컨테이너(Container) 설정   

**자바 기반 설정의 중요 애너테이션 2가지**   
`@Configuration`   
`@Bean`   

메서드가 Spring 컨테이너에서 관리할 새 객체를 인스턴스화, 구성 및 초기화한다는 것을 나타내는 데 사용된다.  
  
```java
// DependencyConfig 클래스
컨텍스트를 인스턴스화할 때
@Configuration
public class DependencyConfig {
    @Bean
    public MyService myService() {
        return new MyServiceImpl();
    }
}
```

```xml
<!-- XML 설정 방식 -->
<beans>
    <bean id="myService" class="com.acme.services.MyServiceImpl"/>
</beans>
```

**스프링 컨테이너를 인스턴스화 하는 방법**  

애너테이션을 이용해 Config 클래스 설정하는 방법.
-> Spring 3.0에 도입된 `AnnotationConfigApplicationContext`  

`ApplicationContext` 구현은 애너테이션이 달린 클래스로 파라미터를 전달 받고 있다.  

- `@Configuration` 클래스  
- `@Component` 클래스  
- JSR-330 메타데이터  

**`@Configuration` 클래스가 입력으로 제공되면** @Configuration 클래스 자체가 Bean 정의로 등록되고 클래스 내에서 선언된 모든 @Bean 메서드도 Bean 정의로 등록된다.  

**`@Component` 클래스와 `JSR-330` 클래스가 제공되면** 빈 정의로 등록되며 필요한 경우 해당 클래스 내에서 @Autowired 또는 @Inject와 같은 DI 메타데이터가 사용되는 것으로 가정한다.  

```java
// @Configuration 클래스 (DependencyConfig.class)
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(DependencyConfig.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

```java
// @Component 또는 JSR-330
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class);
    MyService myService = ctx.getBean(MyService.class);
    myService.doStuff();
}
```

**[@Bean](https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-java-bean-annotation) 애너테이션 사용**  

**- 빈(Bean) 선언**  
`@Bean` 애너테이션을 메서드에 추가해서 Bean으로 정의(선언)할 수 있다.  

```java
// 애너테이션 방식의 configuration
@Configuration
public class DependencyConfig {
    @Bean
    public TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}
```

```xml
<!-- XML 방식의 configuration -->
<beans>
    <bean id="transferService" class="com.acme.TransferServiceImpl"/>
</beans>
```

```java
// 빈 정의가 있는 인터페이스를 구현하여 bean configuration을 설정
public interface BaseConfig {
    @Bean
    default TransferServiceImpl transferService() {
        return new TransferServiceImpl();
    }
}
@Configuration
public class DependencyConfig implements BaseConfig {

}
```

**- 빈 의존성**
`@Bean` 애너테이션이 추가된(@Bean-annotated) 메서드는 빈을 구축하는데 필요한 의존성을 나타내는데 매개 변수를 사용할 수 있다.  

```java
@Configuration
public class DependencyConfig {

    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}
```

**@Configuration 애너테이션 사용**  

- 해당 객체가 bean definitions의 소스임을 나타내는 애너테이션.  
- @Bean-annoted 메서드를 통해 bean을 선언.  
- @Bean 메서드에 대한 호출을 사용하여 bean 사이의 의존성을 정의할 수 있다.  

**- 빈(Bean) 사이에 의존성 주입**

```java
// beanOne은 생성자 주입을 통해 beenTwo에 대한 참조를 받는다.
@Configuration
public class DependencyConfig {
    @Bean
    public BeanOne beanOne() {
        return new BeanOne(beanTwo());
    }
    @Bean
    public BeanTwo beanTwo() {
        return new BeanTwo();
    }
}
```

**Java - 애너테이션을 사용해 Spring 컨테이너를 구성하는 방법**  
애너테이션을 사용해 구성의 복잡성을 줄일 수 있다.  

**`@Import 애너테이션`**  
- XML 파일 내에서 요소가 사용되는 것처럼 구성을 모듈화하는데 사용.    
- 다른 구성 클래스에서 @Bean definitions를 가져올 수 있다.  

```java
@Configuration
public class DependencyConfigA {
    @Bean
    public A a() {
        return new A();
    }
}
@Configuration
@Import(DependencyConfigA.class)
public class DependencyConfigB {
    @Bean
    public B b() {
        return new B();
    }
}
```
- 컨텍스트를 인스턴스화할 때 `DependencyConfigA.class`와 `DependencyConfigB.class` 모두 지정하는 대신 `DependencyConfigB`만 제공하면 된다.  

```java
public static void main(String[] args) {
    ApplicationContext ctx = new AnnotationConfigApplicationContext(DependencyConfigB.class);
    // now both beans A and B will be available...
    A a = ctx.getBean(A.class);
    B b = ctx.getBean(B.class);
}
```
- ctx에 Import(DependencyConfigA.class) 받은 DependencyConfigB.class 사용으로 인해 ctx.getBean(A.class)가 가능해진다.  
- 컨테이너 인스턴스화를 단순화 -> 많은 @Configuration 클래스를 기억할 필요 없이 하나의 클래스만 처리하면 된다.   

**`추가한 @Bean 애너테이션에서 의존성 주입`**  

**`문제점`**   

- 실제 사용시 빈은 1개의 구성 파일만 `@Import` 받지 않고 여러 구성 클래스 간에 걸쳐 서로 의존성을 갖는다.  
- XML을 사용할 때는 컴파일러가 관여하지 않아 컨테이너 초기화 중 ref=”some Bean”을 선언하여 스프링으로 해결할 수 있어 문제가 되지 않는다.  
- @Configuration 클래스를 사용할 때, 자바 컴파일러는 구성 모델에 제약을 두며, 다른 빈에 대한 참조는 유효한 자바 구문이어야 한다.

**`해결방법`**  
- @Bean 메서드는 빈 의존성을 설명하는 임의 개수 파라미터를 가질 수 있다.  
- @Autowired 및 @Value 주입 및 다른 bean과 동일한 기능을 사용할 수 있다.  
- @Configuration의 생성자 주입은 스프링 프레임워크 4.3에서만 지원된다.  
- 대상 빈이 하나의 생성자만 정의하는 경우 @Autowired 지정할 필요가 없다.   

### Component Scan
***스프링은 설정 정보 없이 자동으로 스프링 빈을 등록하는 컴포넌트 스캔 기능을 제공한다.**  

지금까지 스프링 빈을 등록할 때 자바 코드의 `@Bean` 또는 XML의 등의 설정 정보에 등록할 스프링 빈들을 직접 작성했다. 이렇게 수작업으로 등록하면 설정 정보가 커지고, 누락하는 등 다양한 문제가 발생할 수 있다.  

`@ComponentScan`은 `@Component`가 붙은 모든 클래스를 스프링 빈으로 등록해주기 때문에 설정 정보에 붙여주면 된다. 의존관계도 자동으로 주입하는 `@Autowired` 기능도 제공한다.

```java
// AutoDependencyConfig.java 생성
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.FilterType;

@Configuration
@ComponentScan
public class AutoDependencyConfig {

}
```
@Bean으로 등록한 클래스를 볼 수 없다.  
**주의** ⇒ 컴포넌트 스캔을 사용하면 @Configuration이 붙은 설정 정보도 자동으로 등록.  

- `@Configuration`이 붙은 설정 정보가 자동 등록되는 이유는 @Configuration 코드에 `@Component` 애너테이션이 붙어있기 때문.  
- 기존에 작성한 AppConfig이 있다면 정상적인 작동이 되지 않는다.  
- 새 프로젝트로 진행할 경우엔 문제가 되지 않는다.  
- @Configuration 설정이 된 파일이 있을시 아래 코드 추가 :
`@ComponentScan(excludeFilters = @Filter(type = FilterType.ANNOTATION, classes = Configuration.class))`  

```xml
<!---XML 방식의 component scan--->
<beans>
    <context:component-scan base-package="com.acme"/>
</beans>
```

`@ComponentScan` - @ComponentScan이 등록된 곳에서 @Component를 가져오기 위해 사용.  
`@Autowired` - 생성자 의존성 주입에 필요한 설정 정보 대신 의존관계 자동 주입.   

**basePackages**  
탐색할 패키지의 시작 위치를 지정하고, 해당 패키지부터 하위 패키지 모두 탐색.  

- `@ComponentScan()`의 매개변수로 basePackages = “”를 줄 수 있다.  
- 지정하지 않으면, @ComponentScan이 붙은 설정 정보 클래스의 패키지가 시작 위치가 된다.
(설정 정보 클래스의 위치를 프로젝트 최상단에 두고 패키지 위치는 지정하지 않는 방법이 가장 편할 수 있다.)  
- 스프링 부트를 사용하면 `@SpringBootApplication`를 이 프로젝트 시작 루트 위치에 두는 것을 추천.
(@SpringBootApplication에 @ComponentScan이 들어있다.)  

**컴포넌트 스캔 기본 대상**  

- `@Component` : 컴포넌트 스캔에서 사용.   
- `@Controller & @RestController` : 스프링 MVC 및 REST 전용 컨트롤러에서 사용.   
- `@Service` : 스프링 비즈니스 로직에서 사용.    
	- 특별한 처리를 하지 않는다.  
- `@Repository` : 스프링 데이터 접근 계층에서 사용.   
	- 스프링 데이터 접근 계층으로 인식하고, 데이터 계층의 예외를 스프링 예외로 변환해준다.  
- `@Configuration` : 스프링 설정 정보에서 사용.   
	- 스프링 설정 정보로 인식하고, 스프링 빈이 싱글톤을 유지하도록 추가 처리를 한다.  

**필터**   

- **includeFilters** : 컴포넌트 스캔 대상을 추가로 지정.  
- **excludeFilters** : 컴포넌트 스캔에서 제외할 대상을 지정.    
- **FilterType** 옵션  
	- ANNOTATION: 기본값, 애너테이션으로 인식해서 동작.  
	- ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작.  
	- ASPECTJ: AspectJ 패턴을 사용.  
	- REGEX: 정규 표현식을 나타낸다.   
	- CUSTOM: TypeFilter라는 인터페이스를 구현해서 처리.  

### 다양한 의존관계 주입 방법

1. 생성자 주입
2. 수정자 주입 (setter 주입)
3. 필드 주입
4. 일반 메서드 주입


**1. 생성자 주입**  
생성자를 통해서 의존 관계를 주입 받는 방법.  

생성자에 `@Autowired`를 하면 스프링 컨테이너에 `@Component`로 등록된 빈에서 생성자에 필요한 빈들을 주입한다.  

**특징**
- 생성자 호출 시점에 딱 1번만 호출되는 것이 보장된다.
- 불변과 필수 의존 관계에 사용.
- 생성자가 1개만 존재하는 경우에는 `@Autowired`를 생략해도 자동 주입 된다.
- `NullPointerException`을 방지할 수 있다.
- 주입받을 필드를 final로 선언 가능.  

```java
// 예시
@Component
public class CoffeeService {
  private final MemberRepository memberRepository;
  private final CoffeeRepository coffeeRepository;

  @Autowired
  public CoffeeService(MemberRepository memberRepository, CoffeeRepository coffeeRepository) {
    this.memberRepository = memberRepository;
    this.coffeeRepository = coffeeRepository;
  }
}
```

**2. 수정자 주입 (setter 주입)**  
setter 필드의 값을 변경하는 수정자 메서드를 통해서 의존 관계를 주입하는 방법.  

생성자 주입과 차이점은 생성자 대신 set필드명 메서드를 생성하여 의존 관계를 주입하는 것이다.  

**특징**  
- 선택과 변경 가능성이 있는 의존 관계에 사용.  
- 자바 빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법.  

```java
// 예시
@Component
public class CoffeeService {
  private MemberRepository memberRepository;
  private CoffeeRepository coffeeRepository;

  @Autowired
  public void setMemberRepository(MemberRepository memberRepository) {
    this.memberRepository = memberRepository;
  }

  @Autowired
  public void setCoffeeRepository(CoffeeRepository coffeeRepository) {
    this.coffeeRepository = coffeeRepository;
  }
}
```
수정자의 경우 `@Autowired`를 입력하지 않으면 실행이 되지 않는다.  

`@Component`가 실행하는 클래스를 스프링 빈으로 등록한다. 스프링 빈으로 등록한 다음 의존 관계를 주입하게 되는데 `@Autowired`가 있는 것들을 자동으로 주입하게 된다.  

**- 생성자는 1개일 때 @Autowired가 없어도 작동이 되는 이유?**   
-> 스프링이 해당 클래스 객체를 생성하여 빈에 넣어야하는데 생성할 때 생성자를 부를 수 밖에 없게 되기 때문에 빈을 등록하면서 의존 관계 주입도 같이 발생하게 된다.   

**3. 필드 주입**  
필드에 `@Autowired` 붙여서 바로 주입하는 방법.  

**특징**  
- 코드가 간결해 많이 사용된 방식이지만, 외부 변경이 불가능해서 테스트하기 힘들다.  
- DI 프레임워크가 없으면 아무것도 할 수 없다.   
- 실제 코드와 상관 없는 특정 테스트를 하고 싶을 때 사용할 수 있다.  
- 하지만 정상적으로 작동되게 하려면 결국 setter가 필요해서 수정자 주입을 사용하는게 더 편리하다.  

```java
// 예시
@Component
public class CoffeeService {
  @Autowired
  private MemberRepository memberRepository;
  @Autowired
  private CoffeeRepository coffeeRepository;
}
```

**4. 일반 메서드 주입**  
일반 메서드를 사용해 주입하는 방법.  

**특징**  
- 한번에 여러 필드를 주입 받을 수 있다.  
- 일반적으로 사용되지 않는다.  

**옵션 처리**
주입할 스프링 빈이 없을 때 동작해야하는 경우가 있다.  

- `@Autowired`만 사용하는 경우 required 옵션 기본값인 true가 사용되어 자동 주입 대상이 없으면 오류가 발생하는 경우가 있다.  
- 스프링 빈을 옵셔널하게 해둔 상태에서 등록이 되지 않고, 기본 로직으로 동작하게 하는 경우.
- 자동 주입 대상 옵션 처리 방법
	- **@Autowired(required=false)** : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출되지 않게 된다.
	- **org.springframework.lang.@Nullable** : 자동 주입할 대상이 없으면 null이 입력.
	- **Optional &#60; &#62;** : 자동 주입할 대상이 없으면 Optional.empty가 입력.


**생성자 주입을 사용해야하는 이유**  
예전에는 수정자, 필드 주입을 많이 사용했지만, 최근에는 대부분 생성자 주입 사용을 권장한다.

`불변`    
- 의존 관계 주입은 처음 애플리케이션이 실행될 때 대부분 정해지고 종료 전까지 변경되지 않고 변경되서는 안된다.  
- 수정자 주입 같은 경우에는 이름 메서드를 public으로 열어두어 변경이 가능하기 때문에 적합하지 않다.  
- 누군가 실수로 변경할 수도 있고, 애초에 변경하면 안되는 메서드가 변경할 수 있게 설계하는 것은 좋은 방법이 아니다.    
- 생성자 주입은 객체를 생성할 때 최초로 1번만 호출되고 그 이후에는 다시는 호출되는 일이 없기 때문에 불변하게 설계할 수 있다.    

`누락`  
- 호출했을 때는 NPE(Null Point Exception)이 발생하는데 의존관계 주입이 누락되었기 때문에 발생.  
- 생성자 주입을 사용하면 주입 데이터 누락 시 컴파일 오류가 발생.  

`final 키워드 사용 가능`  
- 생성자 주입을 사용하면 필드에 final 키워드를 사용할 수 있다.  
- 생성자에서 값이 설정되지 않으면 컴파일 시점에서 오류를 확인할 수 있다.  
- **java: variable (데이터 이름) might not have been initialized**  
- 생성자 주입을 제외한 나머지 주입 방식은 생성자 이후에 호출되는 형태이므로 final 키워드를 사용할 수 없다.  

`순환 참조`  
- 순환 참조를 방지할 수 있다.
- 개발하다보면 여러 컴포넌트 간에 의존성이 생기게 된다. 
(A → B를 참조하고, B → A를 참조)
- 필드 주입과 수정자 주입은 빈이 생성된 후에 참조를 하기 때문에 애플리케이션이 어떠한 오류와 경고 없이 구동된다.
(실제 코드가 호출될 때까지 문제를 알 수 없다.)
- 생성자를 통해 주입하게되면 `BeanCurrentlyInCreationException`이 발생.  

**생성자 주입 방식의 장점 요약**  
- 의존관계 설정이 되지 않으면 객체생성이 불가능하다.  
	- 컴파일 타임에 인지가 가능하다.  
	- NPE 에러 방지가 가능하다.  
- 의존성 주입이 필요한 필드를 final로 선언이 가능하다.  
- (Spring) 순환참조 감지가 가능하다.  
	- 순환 참조 시 앱구동이 실패하게 된다.  
- 테스트 코드 작성 용이하다.  
- 수정자 주입이 필요한 경우가 있을 수 있지만 옵션이 필요할 때만 선택하면 된다.  

-----
## AOP(Aspect Oriented Programming)

**AOP(Aspect Oriented Programming, 관심 지향 프로그래밍)**  
기존과 다른 프로그램 구조 사고 방식을 제공함으로써 객체 지향 프로그래밍의 부족한 부분을 보조하는 목적으로 개발되었다.  

- OOP의 모듈화의 핵심 단위는 클래스이고, AOP의 모듈화의 핵심 단위는 관점이다.  
- Aspect는 여러 유형과 객체 간에 발생하는 문제의 모듈화를 가능하게 한다.

AOP에서 Aspect는 애플리케이션에 필요한 기능 중에서 공통적으로 적용되는 **공통 기능에 대한 관심** 과 관련이 있다.  

**📍 공통 관심 사항과 핵심 관심 사항**  
애플리케이션을 개발할 때 애플리케이션 전반에 걸쳐 공통적으로 사용되는 기능들이 있는데, 이러한 공통 기능들에 대한 관심사가 **공통 관심 사항(Cross-cutting concern)** 이라고 한다.   

그리고 우리가 흔히들 말하는 비즈니스 로직 즉, 애플리케이션의 주목적을 달성하기 위한 핵심 로직에 대한 관심사를 **핵심 관심 사항(Core concern)** 이라고 한다.  


**카페 주문 애플리케이션을 예로 들면,**  
![](https://velog.velcdn.com/images/wlsk124/post/46973806-01b0-4423-9f17-a3e14b8d907b/image.png)  

- 공통 관심 사항의 기능들이 애플리케이션의 핵심 로직에 전반적으로 두루 사용.  
- 공통 관심 사항이 핵심 관심 사항에서 분리 되어 있다.    

### AOP가 필요한 이유  

- 소프트웨어 개발에서 변경 지점은 하나가 될 수 있도록 잘 모듈화 되어야 한다.  
- 부가 기능처럼 특정 로직을 애플리케이션 전반에 적용하는 문제는 일반적인 OOP 방식으로는 해결이 어렵기 때문에 핵심 기능과 부가 기능을 분리하는 AOP 방식이 필요하다.  

**애플리케이션의 핵심 로직에서 공통 기능을 분리하는 이유**  
- 코드의 간결성 유지  
- 객체 지향 설계 원칙에 맞는 코드 구현  
- 코드의 재사용  

애플리케이션의 핵심 로직에 공통적인 기능의 코드들이 여기 저기 보이면 코드 자체가 복잡해진다. 코드 구성이 복잡해짐에 따라 버그가 발생할 가능성도 높아지고 유지 보수도 어려워진다. 그리고 공통 기능들에 수정이 필요하게 되면 애플리케이션 전반에 적용되어 있는 공통 기능에 해당하는 코드를 일일이 수정해야 되는 문제가 발생할 가능성이 높다.  

**중요한 기본 개념**  

**- 핵심 기능(Core Concerns)**: 업무 로직을 포함하는 기능   
**- 부가 기능(CROSS-CUTTING CONCERNS)**: 핵심 기능을 도와주는 부가적인 기능 
- 로깅, 보안, 트랜잭션 등  

**- Aspect**: 부가 기능을 정의한 코드인 어드바이스(Advice)와 어드바이스를 어디에 적용할지 결정하는 포인트컷(PointCut)을 합친 개념.  
- Advice + PointCut ⇒ Aspect   

**✨ 객체 지향 프로그래밍(Object Oriented Programming:OOP)**  
정의된 기능들을 재사용하기 위해 동작보다는 객체를 중심으로 프로그래밍하는 OOP가 등장했다.  

- OOP의 핵심은 공통된 목적을 띈 데이터와 동작을 묶어 하나의 객체로 정의하는 것이다.  
- 객체를 적극적으로 활용함으로써 기능을 재사용할 수 있는 것이 큰 장점이다.  
- 객체를 잘 활용하기 위해선 관심사 분리 (Separation of Concerns, SoC)의 디자인 원칙을 준수해야 한다.  

**문제점**  

- 특정 관심사 업무 코드에 트랜잭션, 보안, 로깅 등의 코드가 존재하게 된다.
- 트랜잭션, 보안, 로깅 코드는 업무와는 관련이 없지만 애플리케이션에 필수적인 부가 기능이다.
- 트랜잭션, 보안, 로깅 기능은 불특정 다수의 클래스에서 존재하게 된다.
- 관심사 관점에서는 트랜잭션, 보안, 로깅 코드들을 횡단 관심사(Cross-cutting Concerns: 부가 기능)라고 한다.
- 업무 관련 코드는 핵심 관심사(Core Concerns: 핵심 기능)라고 한다.
- 비즈니스 클래스에 횡단 관심사와 핵심 관리사가 공존하게 된다.
	 메서드 복잡도 증가 → 비즈니스 코드 파악이 어렵다.
	 부가 기능의 불특정 다수 메서드가 반복적으로 구현 → 횡단 관심사의 모듈화가 어렵다.

**AOP의 등장**  
OOP만 사용해선 횡단 관심사 코드를 깔끔하게 분리하고 비즈니스 코드에 적용하기 어려웠다. 관심사 분리에 대한 한계적인 부분을 해결하려고 AOP가 등장했다.   

**AOP의 핵심 기능과 부가 기능**
애플리케이션 로직은 크게 핵심 기능과 부가 기능으로 나눌 수 있습니다.

👉🏻 핵심 기능(Core Concerns)   
- 객체가 제공하는 고유의 기능(업무 로직 등을 포함).  

👉🏻 부가 기능(CROSS-CUTTING CONCERNS)  
- 핵심 기능을 보조하기 위해 제공되는 기능.   
- 로그 추적 로직, 보안, 트랜잭션 기능 등이 있다.  
- 단독으로 사용되지 않고 핵심 기능과 함께 사용된다.  

👉🏻 핵심 기능 로직과 부가 기능 로직이 하나의 객체로 들어가게 된다.  

👉🏻 서비스를 실행하면 핵심 기능과 부가 기능이 함께 실행된다.  

**여러 곳에서 공통으로 사용하는 부가 기능**
부가 기능은 여러 클래스에 걸쳐서 함께 사용된다. 이런 부가 기능은 횡단 관심사가 된다.  

- 부가 기능을 여러 곳에 적용하려면 번거롭고 중복 코드가 생기게 된다.
- 부가 기능에 수정이 필요하게 되면 사용되는 클래스에 모두 하나씩 차자가면서 수정해야 한다.


### AOP의 용어 및 개념들

**애스팩트(Aspect)**  
- 여러 객체에 공통으로 적용되는 기능. (공통 기능)   
- 어드바이스 + 포인트컷을 모듈화하여 애플리케이션에 포함되는 횡단 기능.  
- 여러 어드바이스와 포인트컷이 함께 존재한다.  


**조인 포인트(join point)**  

![](https://velog.velcdn.com/images/wlsk124/post/3a4c2728-19fc-4f40-b5df-25a75d640188/image.png)    

S: 메서드 실행 전의 포인트  
E: 메서드 수행 후의 포인트  

- 클래스 초기화, 객체 인스턴스화, 메소드 호출, 필드 접근, 예외 발생과 같은 애플리케이션 실행 흐름에서의 특정 포인트를 의미.  
- 애플리케이션에 새로운 동작을 추가하기 위해 조인포인트에 관심 코드(aspect code)를 추가할 수 있다.  
- 횡단 관심은 조인포인트 전/후에 AOP에 의해 자동으로 추가된다.  
- 추성적인 개념이고 AOP를 적용할 수 있는 모든 지점이라 생각하면 된다.  
- 스프링 AOP는 프록시 방식을 사용하므로 조인 포인트는 항상 메서드 실행 지점으로 제한한다.
- 어드바이스 적용이 필요한 곳은 애플리케이션 내에 메서드를 갖는다.


**어드바이스(Advice)**  
- 조인포인트에서 수행되는 코드를 의미한다.
- Aspect를 언제 핵심 코드에 적용할 지 정의한다.
- 시스템 전체 애스펙트에 API 호출을 제공한다.
- 메서드를 호출하기 전에 각 상세 정보와 모든 메소드를 로그로 남기기 위해 메소드 시작 전의 포인트인 `조인포인트S` 를 선택한다.
- 부가 기능에 해당된다.


**포인트컷(Pointcut)**  
- 조인 포인트 중에서 어드바이스가 적용될 위치를 선별하는 기능.  
- AspectJ 표현식을 사용해서 지정한다.
- 프록시를 사용하는 스프링 AOP는 메서드 실행 지점만 포인트컷으로 선별 가능하다.  

**위빙(Weaving)**    
- 포인트컷으로 결정한 타겟의 조인 포인트에 어드바이스를 적용하는 것.  
- Advice를 핵심 코드에 적용하는 것을 의미.  
- 핵심 기능 코드에 영향을 주지 않고 부가 기능을 추가 할 수 있다.  
- AOP 적용을 위해 애스펙트 객체에 연결한 상태이다.  
	- 컴파일 타임(AspectJ compoiler)  
	- 로드 타임  
	- 런타임, 스프링 AOP는 런타임, 프록시 방식  

**AOP 프록시(proxy)**  
- AOP 기능을 구현하기 위해 만든 프록시 객체.
- 스프링에서 AOP 프록시는 JDK 동적 프록시 또는 CGLIB 프록시이다.  

**타겟 (Target)**  
- 핵심 기능을 담고 있는 모듈로 타겟은 부가기능을 부여할 대상이 된다.  
- Adivce를 받는 객체이고 포인트컷으로 결정된다.  

**어드바이저(Advisor)**  
하나의 어드바이스와 하나의 포인트 컷으로 구성된다.  
스프링 AOP에서만 사용되는 특별한 용어.  

### 타입별 Advice  

**Advice 순서**  
어드바이스는 기본적으로 순서를 보장하지 않는다.

- 순서를 지정하려면 @Aspect 적용 단위로 `org.springframework.core.annotation.@Order` 애너테이션을 적용.   
	- 어드바이스 단위가 아니라 클래스 단위로 적용할 수 있다.  
	- 하나의 애스펙트에 여러 어드바이스가 존재하면 순서를 보장 받을 수 없다.  
- 애스펙트를 별도의 클래스로 분리해야 한다.  

**Advice 종류**  

`Before`  
- 조인 포인트 실행 이전에 실행한다.  
- 타겟 메서드가 실행되기 전에 처리해야할 필요가 있는 부가 기능을 메서드 호출 전에 실행한다.  
- Before Advice 구현한 메서드는 일반적으로 리턴타입이 void이다.  
	- 리턴 값을 갖더라고 실제 Advice 적용 과정에 아무 영향이 없다.  
- 주의점으로 메서드에서 예외를 발생시킬 경우 대상 객체의 메서드가 호출되지 않게 된다.  

```java
// 예시
@Before("hello.aop.order.aop.Pointcuts.orderAndService()")
public void doBefore(JoinPoint joinPoint) {
    log.info("[before] {}", joinPoint.getSignature());
}
// 작업 흐름을 변경할 수 없다.
// 메서드 종료 시 자동으로 다음 타겟이 호출. -> 예외가 발생하면 다음 코드는 호출되지 않는다.
```

`After returning`   
- 조인 포인트가 정상 완료 후 실행한다.  
- 메서드가 예외 없이 실행된 이후에 공통 기능을 실행한다.  

```java
// 예시
@AfterReturning(value = "hello.aop.order.aop.Pointcuts.orderAndService()", returning = "result")
public void doReturn(JoinPoint joinPoint, Object result) {
    log.info("[return] {} return={}", joinPoint.getSignature(), result);
}
// 메서드 실행이 정상적으로 반환될 때 실행된다.
// returning 속성에 사용된 이름은 어드바이스 메서드의 매개변수 이름과 일치해야 한다.
// returning 절에 지정된 타입의 값을 반환하는 메서드만 대상을 실행한다.
```

`After throwing`      
- 메서드가 예외를 던지는 경우에 실행한다.  
- 메서드를 실행하는 도중 예외가 발생한 경우 공통 기능을 실행한다.  

```java
// 예시
@AfterThrowing(value = "hello.aop.order.aop.Pointcuts.orderAndService()", throwing = "ex")
public void doThrowing(JoinPoint joinPoint, Exception ex) {
    log.info("[ex] {} message={}", joinPoint.getSignature(), ex.getMessage());
}
// 메서드 실행이 예외를 던져서 종료될 때 실행.
// throwing 속성에 사용된 이름은 어드바이스 메서드의 매개변수 이름과 일치해야 한다.
// throwing 절에 지정된 타입과 맞은 예외를 대상으로 실행한다.
```

`After (finally)`    
- 조인 포인트의 동작(정상 또는 예외)과는 상관없이 실행한다.  
- 메서드 실행 후 공통 기능을 실행한다.  
- 일반적으로 리소스를 해제하는데 사용한다.  

`Around`   
- 메서드 호출 전후에 수행하며 가장 강력한 어드바이스.  
	- 조인 포인트 실행 여부 선택, 반환 값 변환, 예외 변환 등이 가능하다.    
- 메서드 실행 전 &#38; 후, 예외 발생 시점에 공통 기능을 실행한다.  
- 가장 강력한 어드바이스.   
	- 조인 포인트 실행 여부 선택 - `joinPoint.proceed()`  
	- 전달 값 변환 - `joinPoint.proceed(args[])`  
	- 반환 값 변환  
	- 예외 변환  
	- `try ~ catch ~ finally` 가 들어가는 구문 처리 가능  
- 어드바이스의 첫 번째 파라미터는 `ProceedingJoinPoint`를 사용.  
- proceed()를 통해 대상을 실행한다.  
- proceed()를 여러번 실행할 수 있다.  

**@Around만 있어도 모든 기능 수행이 가능**   
가장 강력한 어드바이스이며 대부분의 기능을 제공하지만 타겟 등 고려해야할 사항이 있을 때 정상적으로 작동이 되지 않는 경우가 있다.  

@Before, @After와 같은 어드바이스는 기능은 적지만 원하는대로 작동되고 코드도 단순하다.

좋은 설계는 @Around만 사용해서 모두 해결하는 것보다는 제약을 가지더라도 실수를 미연에 방지하는 것으로, 제약을 두면 문제 자체가 발생하지 않게 하며, 역할이 명확해진다.   

### Pointcut 표현식  

**포인트컷과 표현식 &#38; 지시자**  
포인트컷은 관심 조인 포인트를 결정해서 어드바이스가 실행되는 시기를 제어할 수 있다.  
AspectJ는 포인트컷을 편리하게 표현하기 위한 특별한 표현식을 제공한다.  
ex) `@Pointcut("execution(* hello.aop.order..*(..))")`  


```java
@Pointcut("execution(* transfer(..))") // 포인트컷 표현식
private void anyOldTransfer() {} // 포인트컷 서명
```

**포인트컷 지시자**  
포인트컷 표현식은 execution 같은 포인트컷 지시자(Pointcut Designator)로 시작.  


**📍 포인트컷 지시자 종류**    

|종류	|설명
|:--:|:--:
|execution|	메서드 실행 조인트 포인트를 매칭. 스프링 AOP에서 가장 많이 사용하며, 기능도 복잡하다.
|within|	특정 타입 내의 조인 포인트를 매칭한다.
|args|	인자가 주어진 타입의 인스턴스인 조인 포인트
|this|	스프링 빈 객체(스프링 AOP 프록시)를 대상으로 하는 조인 포인트
|target|	Target 객체(스프링 AOP 프록시가 가르키는 실제 대상)를 대상으로 하는 조인 포인트
|@target|	실행 객체의 클래스에 주어진 타입의 애너테이션이 있는 조인 포인트
|@within|	주어진 애너테이션이 있는 타입 내 조인 포인트
|@annotation|	메서드가 주어니 애너테이션을 가지고 있는 조인 포인트를 매칭
|@args|	전달된 실제 인수의 런타임 타입이 주어진 타입의 애너테이션을 갖는 조인 포인트
|bean|	스프링 전용 포인트컷 지시자이고 빈의 이름으로 포인트컷을 지정한다.  

`execution` 을 가장 많이 사용하고 나머지는 자주 사용하지 않는다.  

**Pointcut 표현식 결합**  
- `&&, ||, !` 를 사용하여 결합할 수 있다.  
- 이름으로 참조할 수도 있다.  

```java
@Pointcut("execution(public * *(..))")
private void anyPublicOperation() {} 
//anyPublicOperation은 메서드 실행 조인 포인트가 공용 메서드의 실행을 나타내는 경우 일치.

@Pointcut("within(com.xyz.myapp.trading..*)")
private void inTrading() {} 
//inTrading 메서드 실행이 거래 모듈에 있는 경우에 일치.

@Pointcut("anyPublicOperation() && inTrading()")
private void tradingOperation() {} 
//tradingOperation은 메서드 실행이 거래 모듈의 공개 메서드를 나타내는 경우 일치.
```

**일반적인 pointcut 표현식들**  
✨ -> Spring AOP에서만 메서드 실행

- 모든 공개 메서드 실행    
`execution(public * *(..))`    

- `set` 다음 이름으로 시작하는 모든 메서드 실행  
`execution(* set*(..))`  

- `AccountService` 인터페이스에 의해 정의된 모든 메서드의 실행  
`execution(* com.xyz.service.AccountService.*(..))`  

- `service` 패키지에 정의된 메서드 실행  
`execution(* com.xyz.service.*.*(..))`  

- 서비스 패키지 또는 해당 하위 패키지 중 하나에 정의된 메서드 실행  
`execution(* com.xyz.service..*.*(..))`  

- ✨ 서비스 패키지 내의 모든 조인 포인트  
`within(com.xyz.service.*)`  

- ✨ 서비스 패키지 또는 하위 패키지 중 하나 내의 모든 조인 포인트  
`within(com.xyz.service..*)`  

- ✨ `AccountService` 프록시가 인터페이스를 구현하는 모든 조인 포인트  
`this(com.xyz.service.AccountService)`  

- ✨ `AccountService` 대상 객체가 인터페이스를 구현하는 모든 조인 포인트   
`target(com.xyz.service.AccountService)`  

- ✨ 단일 매개변수를 사용하고 런타임에 전달된 인수가 `Serializable`과 같은 모든 조인 포인트  
`args(java.io.Serializable)`

- ✨ 대상 객체에 `@Transactional`이 있는 모든 조인 포인트   
`@target(org.springframework.transaction.annotation.Transactional)`

- ✨ 실행 메서드에 `@Transactional`이 있는 조인 포인트   
`@annotation(org.springframework.transaction.annotation.Transactional)`  

- ✨ 단일 매개 변수를 사용하고 전달된 인수의 런타임 유형이 `@Classified`을 갖는 조인 포인트  
`@args(com.xyz.security.Classified)`  

- ✨ `tradeService` 라는 이름을 가진 스프링 빈의 모든 조인 포인트   
`bean(tradeService)`  

- 와일드 표현식 `*Service` 라는 이름을 가진 스프링 빈의 모든 조인 포인트  
`bean(*Service)`  

### JoinPoint

AOP를 적용할 수 있는 지점을 의미 = 적용 가능 지점    

>**AOP 적용 위치**    
JoinPoint: 생성자, 필드 값 접근, static 메서드 접근, 메서드 실행.   
AOP를 수행하는 메소드는 이 JoinPoint 인스턴스를 인자로 받게 된다.  
JoinPoint 인스턴스에서 조인 포인트 지점의 정보를 얻어내야한다.  

- 어드바이스가 적용될 수 있는 위치, 메소드 실행, 생성자 호출, 필드 값 접근, static 메서드 접근 같은 프로그램 실행 중 지점을 나타낸다.  
- AspectJ를 사용해서 컴파일 시점과 클래스 로딩 시점에 적용하는 AOP는 바이트코드를 실제 조작하기 때문에 해당 기능을 모든 지점에 다 적용할 수 있다.  
- 프록시 방식을 사용하는 스프링 AOP는 메서드 실행 지점에만 AOP를 적용할 수 있다.  
- 프록시는 메서드 오버라이딩 개념으로 동작한다.  
- 생성자나 static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없다.  
- 프록시를 사용하는 스프링 AOP의 조인 포인트는 메서드 실행으로 제한된다.
- 프록시 방식을 사용하는 스프링 AOP는 스프링 컨테이너가 관리할 수 있는 스프링 빈에만 AOP를 적용할수 있다.   
- JoinPoint 메소드는 어드바이스의 종류에 따라 사용방법이 다르지만 기본적으로 어드바이스 메소드에 매개변수로 선언만 하면 된다.  

**JoinPoint 인터페이스의 주요 기능**   

- `JoinPoint.getArgs()` : JoinPoint에 전달된 인자를 배열로 반환한다.  

- `JoinPoint.getThis()` : AOP 프록시 객체를 반환한다.  

- `JoinPoint.getTarget()` : AOP가 적용된 대상 객체를 반환한다.  
	- 클라이언트가 호출한 비즈니스 메서드를 포함하는 비즈니스 객체를 반환한다.  

- `JoinPoint.getSignature()` : 조언되는 메서드에 대한 설명을 반환한다.  
	- 클라이언트가 호출한 메서드의 시그니처(리턴타입, 이름, 매개변수) 정보가 저장된 `Signature` 객체를 반환한다.  
	- Signature: 객체가 선언하는 모든 메서드에서 메서드의 이름, 매개변수를 담고있는 객체들.  
	- **Signature가 제공하는 메서드**  
	👉🏻 `String getName()` : 호출한 메서드의 이름을 반환.  
	👉🏻 `String toLongString()` : 호출한 메서드의 리턴타입, 이름, 매개변수를 패키지 경로까지 포함해서 반환.  
	👉🏻 `String toShortString()` : 호출한 메서드 시그니처를 축약한 문자열로 반환.  
    
- `JoinPoint.toString()` : 조언되는 방법에 대한 유용한 설명을 인쇄한다.


**ProceedingJoinPoint 인터페이스의 주요 기능**  

- `proceed()` : 다음 어드바이스나 타켓을 호출.  

### 애너테이션(Annotation)을 이용한 AOP

**Spring AOP 지원**  

- @AspectJ 애너테이션 스타일  
- 스키마 기반 접근  
 
**@AspectJ 지원**  
`@AspectJ` : 애너테이션이 있는 일반 Java 클래스로 관점을 선언하는 스타일.  

- @AspectJ 스타일은 AspectJ 5 릴리스의 일부로 AspectJ 프로젝트에 의해 도입.  
- 스프링은 pointcut 구문 분석 및 일치를 위해 AspectJ가 제공하는 라이브러리를 사용해 AspectJ 5와 동일한 애너테이션을 해석한다.  
- AOP 런타임은 순수한 스프링 AOP이며, AspectJ 컴파일러나 위버에 의존하지 않는다.  

**@AspectJ 지원 활성화**   
Spring 설정에서 @AspectJ aspect를 사용하기 위해서 @AspectJ aspect에 기반한 Spring AOP 설정과 이러한 aspect에 의해 조언되는 자동 프록시 빈에 대한 Spring 지원을 활성화해야 한다.  

- @AspectJ 지원은 XML 또는 Java 스타일 설정으로 활성화할 수 있다.  

- Java 설정으로 @AspectJ 지원 활성화 방법   
```java
// @Configuration으로 @AspectJ 지원을 활성화하려면 @EnableAspectJAutoProxy 애너테이션 추가.
@Configuration
@EnableAspectJAutoProxy
public class AppConfig {
}
```
- XML 설정으로 @AspectJ 지원 활성화 방법  
```xml
<!---XML 기반 구성으로 @AspectJ 지원을 활성화하려면 aop:aspectj-autoproxy 요소 사용--->
<aop:aspectj-autoproxy/>
```

**Aspect 선언**  
@AspectJ 지원이 활성화되면 @AspectJ 관점(@Aspect 애너테이션)이 있는 클래스로 애플리케이션 컨텍스트에 정의된 모든 빈이 Spring에서 자동으로 감지되고 Spring AOP를 구성하는 데 사용된다.  

```xml
<bean id="myAspect" class="org.xyz.NotVeryUsefulAspect">
    <!-- configure properties of the aspect here -->
</bean>

```
```java
import org.aspectj.lang.annotation.Aspect;

@Aspect
public class NotVeryUsefulAspect {
}
```

**포인트컷 선언**  

- 포인트컷은 관심 조인 포인트를 결정하므로 어드바이스가 실행되는 시기를 제어할 수 있다.
- Spring AOP는 Spring Bean에 대한 메서드 실행 조인 포인트만 지원하므로 Pointcut은 Spring Bean의 메서드 실행과 일치하는 것으로 생각할 수 있다.  
- pointcut 선언은 이름과 매개변수를 포함하는 서명과 우리가 관심 있는 메서드 실행을 정확히 결정하는 pointcut 표현식의 두 부분으로 구성된다.
- pointcut 표현식은 @Pointcut 어노테이션을 사용하여 표시된다.

**어드바이스 선언**   

- 어드바이스는 포인트컷 표현식과 연관되며 포인트컷과 일치하는 메서드 실행 전후 또는 전후에 실행된다.  
- pointcut 표현식은 명명된 pointcut에 대한 단순 참조이거나 제자리에 선언된 pointcut 표현식일 수 있다.  

-----
## PSA(Portable Service Abstraction)

### PSA(Portable Service Abstraction)란?  

**추상화(Abstraction)의 개념**  

객체지향 프로그래밍 세계에서 추상화(Abstraction)의 의미는 아래 그림(the bull)의 의미와 비슷하다.

![](https://velog.velcdn.com/images/wlsk124/post/6eb90698-ea81-41f6-8fef-8ff9c31e253b/image.png)

왼쪽에서 오른쪽으로 갈수록 황소의 모습이 단순화 되어 간다.  

첫번째 구체적인 모습을 보지 않았더라도 소의 형상과 비슷하다는 생각을 할 수 있다. 결론적으로 특성을 잘 살린 황소의 본질만을 남기려고 했음을 추측할 수 있다.   

-> 객체지향 프로그래밍에서는 어떤 클래스의 본질적인 특성만을 추출해서 일반화 하는것을 추상화(Abstraction)라고 한다.  

Java에서 추상화를 표현할 수 있는 대표적인 방법: `추상 클래스와 인터페이스`  

**추상화의 예**  
- 미취학 아동을 관리하는 애플리케이션을 설계하면서 아이 클래스를 일반화(추상화).   
Java의 클래스는 속성을 나타내는 멤버 변수와 동작을 나타내는 메서드로 구성되므로, 아기의 속성과 동작을 일반화해서 멤버 변수와 메서드로 표현.  

```java
public abstract class Child {
//아이를 관리하는 관점에서 아이의 일반적인 속성 추출
    protected String childType;
    protected double height;
    protected double weight;
    protected String bloodType;
    protected int age;
//일반적으로 아이가 할 수 있는 동작 추출
    protected abstract void smile();

    protected abstract void cry();

    protected abstract void sleep();

    protected abstract void eat();
}
```
**추상화를 하는 이유**  

```java
// NewBornBaby.java(신생아)
public class NewBornBaby extends Child {
    @Override
    protected void smile() {
        System.out.println("신생아는 가끔 웃어요");
    }

    @Override
    protected void cry() {
        System.out.println("신생아는 자주 울어요");
    }

    @Override
    protected void sleep() {
        System.out.println("신생아는 거의 하루 종일 자요");
    }

    @Override
    protected void eat() {
        System.out.println("신생아는 분유만 먹어요");
    }
}

// Infant.java(2개월 ~ 1살)
public class Infant extends Child {
    @Override
    protected void smile() {
        System.out.println("영아는 많이 웃어요");
    }

    @Override
    protected void cry() {
        System.out.println("영아는 종종 울어요");
    }

    @Override
    protected void sleep() {
        System.out.println("영아부터는 밤에 잠을 자기 시작해요");
    }

    @Override
    protected void eat() {
        System.out.println("영아부터는 이유식을 시작해요");
    }
}

// Toddler.java(1살 ~ 4살)
public class Toddler extends Child {
    @Override
    protected void smile() {
        System.out.println("유아는 웃길 때 웃어요");
    }

    @Override
    protected void cry() {
        System.out.println("유아는 화가나면 울어요");
    }

    @Override
    protected void sleep() {
        System.out.println("유아는 낮잠을 건너뛰고 밤잠만 자요");
    }

    @Override
    protected void eat() {
        System.out.println("유아는 딱딱한 걸 먹기 시작해요");
    }
}

public class ChildManageApplication {
    public static void main(String[] args) {
        Child newBornBaby = new NewBornBaby();
        Child infant = new Infant();
        Child toddler = new Toddler();

        newBornBaby.sleep();
        infant.sleep();
        toddler.sleep();
    }
}

```
상위 클래스에 정의된 일반화 된 특징을 하위 클래스의 특징에 맞게 사용.  
-> Child라는 상위 클래스에 일반화 시켜 놓은 아이의 동작을 NewBornBaby, Infant, Toddler 라는 클래스로 연령별 아이의 동작으로 구체화 시켜서 사용하고 있다.

📍 클라이언트(ChildManageApplication 클래스의 main() 메서드)는NewBornBaby, Infant, Toddler를 사용할 때 구체화 클래스의 객체를 자신의 타입에 할당하지 않고, Child 클래스 변수에 할당을 해서 접근을 한다. 클라이언트 입장에서는 Child 라는 추상 클래스만 일관되게 바라보며 하위 클래스의 기능을 사용할 수 있다.  

**추상화(PSA)의 기본 개념  
: 클라이언트가 추상화 된 상위 클래스를 일관되게 바라보며 하위 클래스의 기능을 사용.**  

**PSA가 필요한 이유**   

어떤 서비스를 이용하기 위한 접근 방식을 일관된 방식으로 유지함으로써 애플리케이션에서 사용하는 기술이 변경되더라도 최소한의 변경만으로 변경된 요구 사항을 반영할 수 있다.  
애플리케이션의 요구 사항 변경에 유연하게 대처할 수 있다.  

**PSA가 적용된 분야**  

트랜잭션 서비스, 메일 서비스, Spring Data 서비스 등  

-----
## Spring Framework 모듈 구성
  
### 아키텍처(Architecture)란?  
  
어떠한 시스템을 구축하는데 있어 해당 시스템의 비지니스적 요구 사항을 만족하는 전체 시스템 구조를 정의하는 것이며, 이해 당사자들이 전체 시스템 구조를 이해하는데 무리가 없도록 일반적으로 이미지나 도형 등을 많이 사용한다.  

**아키텍처 유형**
1. 시스템 아키텍처
2. 소프트웨어 아키텍처 / 애플리케이션 아키텍처

### 시스템 아키텍처  

시스템 아키텍처는 하드웨어와 소프트웨어를 모두 포함하는 어떤 시스템의 전체적인 구성을 큰그림으로 표현한 것으로 기본적으로 해당 시스템이 어떤 하드웨어로 구성되고, 어떤 소프트웨어를 사용하는지를 대략적으로 알 수 있다.  

또한 해당 시스템 구성 요소들 간의 상호작용이 어떻게 이루어지는지 등 시스템이 정상적으로 동작하기위한 동작 원리 등이 시스템 아키텍처 안에 표현이 되면 이해 당사자들이 해당 아키텍처를 이해하는데 도움이 된다.  

![](https://velog.velcdn.com/images/wlsk124/post/36a99c8d-e562-4fba-819e-768a1326319d/image.png)  

아키텍처 사용자의 요청을 분산시켜주는 로드 밸런서 영역이 웹소켓 서버를 안정적으로 운영할 수 있도록 하고 있다.
여러대의 웹소켓 서버로 확장이 가능하기 때문에 사용자의 요청이 늘어나더라도 서버의 부하를 줄일 수 있으며, 특정 서버에 장애가 발생하더라도 전체 시스템이 죽는 경우를 방지할 수 있다.


### 소프트웨어 아키텍처

소프트웨어는 하드웨어를 제외한 컴퓨터내의 모든 프로그램을 포괄하는 의미를 가지고 있으며 이러한 소프트웨어의 구성을 큰 그림으로 표현한 것이 소프트웨어 아키텍처이다.

![](https://velog.velcdn.com/images/wlsk124/post/3bd99b31-1e1f-4731-ad1f-9cdbc4146c21/image.png)  

**Java 플랫폼 아키텍처**  
Java를 포함한 Java 플랫폼에 대한 아키텍쳐를 마치 벽돌을 쌓은 듯한 모습으로 표현한 아키텍처. Java가 어떤 기술들을 지원하고 Java를 통해서 어떤 기능들을 사용할 수 있는지 등을 큰 그림으로 접근할 수 있다.  

### 애플리케이션 아키텍처  

소프트웨어 종류의 하나로써 좁게는 데스크탑이나 스마트폰에서 사용하는 응용 프로그램을 말하며, 넓게는 클라이언트의 요청을 처리하는 서버 애플리케이션을 의미한다.  

애플리케이션의 아키텍처 유형에는 다양한 유형이 있다. 그 중 계층형 아키텍처(N-티어)에 대해서 간단히 정리해봤다.  

![](https://velog.velcdn.com/images/wlsk124/post/e583fed3-3854-43e3-98c5-c0146617eb0e/image.png)  

**API 계층(API Layer)**  
클라이언트의 요청을 받아들이는 계층.   

일반적으로 표현 계층(Presentation Layer)라고도 불리지만 REST API를 제공하는 애플리케이션의 경우 API 계층이라고 표현한다.  

**서비스 계층(Service Layer)**  
서비스 계층은 API 계층에서 전달 받은 요청을 업무 도메인의 요구 사항에 맞게 비즈니스적으로 처리하는 계층.  

애플리케이션의 핵심 로직은 서비스 계층에 포함되어 있다고 해도 과언이 아닐만큼 애플리케이션에 있어 핵심이 되는 계층이다.  

>**도메인(Domain)이란?**   
주로 비즈니스적인 어떤 업무 영역.  
>
예를들어, 고객이 음식을 주문하는 과정, 주문받은 음식을 처리하는 과정, 조리된 음식을 배달하는 과정 등의 도메인 지식(Domain Knowledge)들을 서비스 계층에서 비즈니스 로직으로 구현 해야한다.  

**데이터 액세스 계층(Data Access Layer)**  
데이터 액세스 계층은 비즈니스 계층에서 처리된 데이터를 데이터베이스 등의 데이터 저장소에 저장하기 위한 계층.

### 아키텍처로 보는 Spring Framework 모듈(Module) 구성

![](https://velog.velcdn.com/images/wlsk124/post/3f28913d-ccea-4350-b130-9ef3372a40ac/image.png)

Spring Framework에서는 약 20여개의 모듈을 통해 다양한 기능들을 제공하한다.

**모듈(Module)이란?**  
Java에서는 일반적으로, 지원되는 여러가지 기능들을 목적에 맞게 그룹화 하여 묶어 놓은 것을 모듈이라고 부른다.  

모듈들은 Java의 패키지 단위로 묶여 있으며, 이 패키지 안에는 관련 기능을 제공하기 위한 클래스들이 포함되어 있습니다.

일반적으로 모듈은 재사용 가능하도록 라이브러리 형태로 제공되는 경우가 많다.

-----
## Spring Boot 소개
### Spring Boot란?  

Spring Framework은 엔터프라이즈 애플리케이션을 개발하기 위한 핵심 기능을 제공하는 Spring Project.

Spring Boot은 Spring Framework의 편리함에도 불구하고 Spring 설정의 복잡함으로 인해 Spring 기반 애플리케이션 개발을 시작하기도 전에 어려움을 겪는 문제점을 해결하기 위해 생겨난 Spring Project.

### Spring Boot을 사용해야 하는 이유  

1. XML 기반의 복잡한 설계 방식 지양  
2. 의존 라이브러리의 자동 관리  
3. 애플리케이션 설정의 자동 구성  
4. 프로덕션급 애플리케이션의 손쉬운 빌드  
5. 내장된 WAS를 통한 손쉬운 배포  

**1. XML 기반의 복잡한 설계 방식 지양**  
Spring Boot 이 전의 Spring 애플리케이션 개발을 위한 설정은 굉장히 복잡했다. 하지만 Spring Boot으로 인해 개발자는 Spring의 복잡한 설정에 대한 어려움으로부터 벗어날 수 있게 되었습니다.  


**2. 의존 라이브러리의 자동 관리**  
Spring Boot 이 전에는 애플리케이션에서 필요한 라이브러리를 사용하기 위해서는 필요한 라이브러리의 이름과 버전을 일일이 추가해야 했다.   
-> 라이브러리 간의 버전 불일치로 인한 빌드 및 실행 오류가 빈번하게 발생.  하지만 Spring Boot의 starter 모듈 구성 기능을 통해 의존 라이브러리를 수동으로 설정하는 불편함이 사라졌다.  

**3. 애플리케이션 설정의 자동 구성**  
Spring Boot은 스타터(Starter) 모듈을 통해 설치되는 의존 라이브러리를 기반으로 애플리케이션의 설정을 자동으로 구성해 번거로움을 최소화 해준다.  

**예를들어,**   
`“implementation 'org.springframework.boot:spring-boot-starter-web’”` 와 같은 starter가 존재한다면 애플리케이션이 웹 애플리케이션이라고 추측한 뒤, 웹 애플리케이션을 띄울 서블릿 컨테이너(디폴트: Tomcat) 설정을 자동으로 구성한다.  
`“implementation 'org.springframework.boot:spring-boot-starter-jdbc’”` 와 같은 starter가 존재한다면 애플리케이션에 데이터베이스 연결이 필요하다고 추측한 뒤, JDBC 설정을 자동으로 구성한다.  

```java
@SpringBootApplication //Spring Boot 자동 구성 활성화
public class SampleApplication {
    public static void main(String[] args) {
        SpringApplication.run(SampleApplication.class, args);
    }
}
```

**4. 프로덕션급 애플리케이션의 손쉬운 빌드**  
개발한 애플리케이션 구현 코드를 손쉽게 빌드해 직접 빌드 결과물을 War 파일 형태로 WAS(Web Application Server)에 올릴 필요가 없다.

>**WAS(Web Application Server)란?**  
>
Java 기반의 웹 애플리케이션을 배포하는 일반적인 방식은 개발자가 구현한 애플리케이션 코드를 WAR(Web application ARchive) 파일 형태로 빌드한 후에 WAS(Java에서는 서블릿 컨테이너라고도 부릅니다)라는 서버에 배포해서 해당 애플리케이션을 실행하는 것이다.   
Java 진영에서 사용되는 대표적인 WAS에는 **Tomcat**이 있다.  
>
즉, WAS는 구현된 코드를 빌드해서 나온 결과물을 실제 웹 애플리케이션으로 실행되게 해주는 서버이다.  


**5. 내장된 WAS를 통한 손쉬운 배포**  
Apache Tomcat이라는 WAS를 내장하고 있기때문에 별도의 WAS를 구축할 필요가 없으며, Spring Boot을 통해 빌드된 jar 파일을 이용해서 명령어 한 줄만 입력 해주면 서비스 가능한 웹 애플리케이션을 실행 할 수 있다.   

Spring Boot을 사용하면 `java -jar <jar 파일명>.jar` 명령어를 통해 애플리케이션을 손쉽게 실행할 수 있다.
