---
title: "자료구조 심화"
layout: post
date: 2022.06.24
headerImage: false
tag:
- data structure
- Concept
- Back-end
category: study
author: Jina Kim
---


## Circular Queue
 
선형 큐의 문제점을 보완하기 위한 자료구조.

**선형 큐의 문제점**   

![](https://velog.velcdn.com/images/wlsk124/post/84ae6051-2d62-4910-8e7a-11f58b29ac61/image.png)     

(가장 앞에 있는 요소를 front, 마지막에 있는 요소를 rear라고 한다.)  

rear이 배열의 마지막 인덱스를 가르키고 있을 때, Dequeue로 발생한 배열의 빈 공간을 활용 할 수 없다.   

**-> 해결법 : 원형 큐(Circular Queue) 사용**  
원형 큐 포인터 증가 방식이 `(rear+1) % arraysize` 형식으로 변환하기 때문에 배열의 첫 인덱스부터 다시 데이터의 삽입이 가능하다.  

if `rear + 1 == 5(overflow)`, `(rear + 1) % 5 = 0 (start of queue)`


### 데이터 입출력 과정  

**Enqueue**  

rear의 포인터를 1증가 시키고 그 위치에 데이터 삽입이 이루어진다.  

만약 `rear+1`이 배열의 끝이고 포화상태가 아니라면 배열의 첫 번째 인덱스에 데이터를 삽입한다.  

배열의 포화상태 여부를 판단하기 위하여 배열의 1칸은 비워둔다.  

`(rear+1)%arraysize == front` 라면 배열을 포화상태로 판단.  
-> 데이터 삽입이 이루어지지 않는다.   

**Dequeue**  

front의 포인터를 1증가 시키고 그 위치의 데이터를 배열에서 가지고 온다.  

`rear==front` 라면 배열이 공백 상태로 판단  
-> Dequeue가 실행되지 않는다.  


-----
## Deque(Double Ended Queue)

양방향 대기열이라고도 불리는 자료구조.  

### Deque의 구조  

실의 양쪽에 구슬을 꿰어 넣는 것과 비슷한 구조.  

Deque는 양방향으로 열려있는 구조로, Queue와 외형적으로 비슷한 구조지만,  
Deque는 Queue와 Stack과 달리 FIFO, LIFO와 같은 순서에 구속되지 않는다.  

### Deque의 특징  

**1. Stack 및 Queue를 모두 사용할 수 있다.**  

양쪽으로 데이터를 추가, 삭제할 수 있어서 Stack과 Queue를 구현할 수 있다.  

📍 첫 번째, 추가를 제한하는 구조.

```java
// 한쪽에서만 데이터 추가가 가능, 삭제는 양방향에서 가능한 구조.
---------------------------
-> insert
<- delete         delete ->
---------------------------
```
데이터 추가의 방향이 정해진 상태가 된다.   
왼쪽으로 삭제하는 형태는 Stack과 같고, 오른쪽으로 삭제는 Queue와 같다.  

📍 두 번째, 삭제를 제한하는 구조.  

```java
// 데이터의 추가는 양쪽에서 가능, 삭제는 한 방향에서만 가능한 구조.
---------------------------
-> insert         insert <-
<- delete
---------------------------
```
데이터 삭제의 방향이 정해진 상태가 된다.  
왼쪽에서 추가하는 형태는 Stack과 같고, 오른쪽에서 추가는 Queue와 같다.  

**2. 양방향 끝에서 데이터 추가, 삭제가 용이하다.**   

```java
-----
  3    // 3추가
-----
-----------
  2  |  3    // 왼쪽에 2추가
-----------
-----------------
  2  |  3  |  4    // 오른쪽에 4추가
-----------------
-----------------------
  1  |  2  |  3  |  4    // 왼쪽에 1추가
-----------------------
L                      R
```

Deque에서 양쪽의 추가할 데이터나 삭제할 데이터의 인덱스 정보를 가지고 있어서 양쪽 끝의 데이터 접근과 추가, 삭제가 용이하다.

**3. 양방향 끝이 아닌 임의의 데이터만 추가하거나 삭제하는 건 불가능하다.**   

Deque는 양방향 끝의 인덱스 정보를 가지고 있다.  

중간에 있는 데이터에 접근하려고 할 때 양쪽 끝 이외의 인덱스 정보가 없어서 접근할 수 없다.  
-> 임의의 인덱스만 추가, 삭제하는 것은 불가능하다.

-----
## Linked List

선형으로 그룹화된 데이터의 집합.  

데이터와 다음 데이터의 주소를 포함하고 있는 하나의 노드가 선형으로 연결된 자료구조.  

### 일상 속 예시  

> 첫 번째 학생부터 마지막 학생까지 마니또를 알기 위해 찾아 다닌다.  
내 마니또가 누군지 한명 한명 물어보고 알아낸다.  
학생은 제비에 적힌 자신의 마니또 밖에 모른다.    

배열 - 교실에 학생들이 일렬로 놓여있는 의자에 번호순으로 앉은 상태.  
Linked List - 반 전체 학생 이름이 적힌 종이로 제비를 뽑아 마니또를 정한 상태.   

### Linked List의 구조  

|자료구조|설명|
|:---:|:---:|
|Array|연속된 공간 안에 메모리를 차지하고 인덱스로 각각의 요소의 데이터를 읽거나 쓸 수 있는 자료구조. 연속된 메모리 주솟값 안에 데이터를 넣는 구조로 위치를 바꾸려면 데이터가 이동해야 합니다.|
|Linked List&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;|연속된 공간이 아니라 흩어져 있는 공간에 노드들의 연결로 이루어진 자료구조. 하나의 노드에는 데이터와 다음 노드의 주소가 담겨있다. 마지막 노드는 null을 가리킨다.

![](https://velog.velcdn.com/images/wlsk124/post/45b4ea6d-45b2-4f13-8d1f-99d4bdd7d5dd/image.png)  

**메모리에 표시한 링크드 리스트와 배열**

### Linked List의 특징

**1. 노드의 추가와 삭제가 빠르고 쉽다.**  

순서가 지정되지 않아서 데이터를 담은 노드를 어디든 쉽게 추가, 삭제할 수 있다.  
배열은 Linked List보다 추가하거나 삭제하는 경우 시간 복잡도가 많이 걸린다.

![](https://velog.velcdn.com/images/wlsk124/post/8d4b19d7-b0d4-4ea5-a4f9-af5f01517416/image.png)

**- 배열의 추가**  

중간에 데이터를 추가하고 싶을 때   

1. 제일 마지막 인덱스를 새로 만든다.  
2. 삽입하고자 하는 인덱스까지 모든 데이터를 한 칸씩 이동한다.  
3. 원하는 인덱스에 값을 추가한다.  

가장 마지막 인덱스에 데이터를 추가할 때는 가장 빠른 O(1)의 시간복잡도를 보이지만, 0번 인덱스에 데이터를 추가하는 경우 모든 데이터를 오른쪽으로 옮겨야 하므로 최악의 경우 O(n)의 시간복잡도를 가진다.  
-> 마지막 요소의 수정은 빠르지만 가장 앞의 요소의 수정은 가장 오래 걸린다.

삭제는 추가의 반대 과정으로 동작한다.  

**- 연결 리스트의 추가**  

연결 리스트의 노드에는 데이터와 다음 노드의 메모리 주소가 함께 들어있다.  

1. `1 → 2 → 4 → 5`로 연결되어 있다.  
2. 1은 2를,  2는 4를, 4는 5를 가리키고 있다.  
3. 5는 마지막에 있어서 아무것도 가리키고 있지 않다.  

중간에 데이터를 추가하고 싶을 때  

1. 2는 3를 가리키게 바꾸고, 3는 4를 가리키게 바꾼다.  
2. `1 → 2 → 3 → 4 → 5`로 연결 리스트에 3를 추가 할 수 있다.  

연결 리스트는 어떤 위치에 노드를 추가하거나 삭제해도 O(1)의 빠른 시간복잡도를 보여준다.  
-> 다음 노드를 가리키는 메모리 주소만 변경하면 쉽게 추가 할 수 있다.  

삭제는 추가의 반대 과정으로 동작한다.  

**2. 노드의 값을 찾으려면 최대 전체를 순회해야 한다.**  

![](https://velog.velcdn.com/images/wlsk124/post/def9fda4-11b1-477d-9391-7bc3298ab69a/image.png)  

Linked List의 첫 번째 노드 - head node  
(순회하기 전까지는 **head node의 정보** 만 알고 있다.)  

**head node의 정보**  
head node는 값: 1   
size(뒤로 붙은 노드의 개수): 3  
next(다음에 올 노드의 값): 2  

필요한 값이 있는지 확인하려면 head node에 연결된 다음 노드로 접근 하고, 접근한 노드에 원하는 값이 없다면 다시 다음 노드로 이동해야 한다.  

|배열|연결 리스트|
|:----:|:---:|
|연속적으로 이어져 있어 주소의 계산이 쉽다.(쉽게 접근)|노드가 메모리에 흩어져 있어서 특정 노드로 쉽게 접근할 수 없다.|
|인덱스 값을 계산하기 쉬워서 데이터에 접근하는데 O(1)의 시간복잡도를 가진다.|head node의 값은 O(1)의 시간복잡도를 가지지만, 마지막 요소의 값은 요소의 개수만큼 순회해야 하기 때문에 O(n)의 시간 복잡도를 가진다.|

### Linked List 활용 예시  

1. 삽입과 삭제가 중요한 곳에 활용.  
 -> join, split method 처럼 데이터 삽입, 삭제가 중요한 메소드의 구현에도 활용할 수 있다.  

2. 동적 기억장소 관리 (dynamic storage management)  
 -> 작업에 필요한 크기만큼의 메모리를 할당하는 방법에 활용된다.  
 
3. Garbage collection  
 -> 참조자료형의 데이터 타입을 관리하는 알고리즘 중 하나다.

4. 해시테이블의 충돌 시 해결법 중 chaning 방법을 사용할 때 활용.

-----
## Binary Search Tree

트리 구조는 편리한 구조를 전시하는 것 외에 효율적인 탐색을 위해 사용하기도 한다.  

>**이진 트리(Binary tree)**  
: 자식 노드가 최대 두 개인 노드들로 구성된 트리.  
자료의 삽입, 삭제 방법에 따라 Full binary tree(정 이진 트리), Complete binary tree(완전 이진 트리), Perfect binary tree(포화 이진 트리)로 나뉜다.  

![](https://velog.velcdn.com/images/wlsk124/post/4a478f6f-fd58-4d5f-baa7-0dbfeadbf2ab/image.png)

|종류|설명
|:---:|:---:
|Full(Proper) binary tree|모든 parent/internal node가 2개 또는 0개의 child nodes 가진 트리.
|Complete binary tree|마지막 레벨을 제외한 모든 노드가 가득 차 있고, 마지막 레벨은 왼쪽 노드가 채워져 있어는 트리.
|Perfect binary tree|모든 internal node가 2개의 child nodes를 가지고 모든 leaf nodes가 같은 레벨에 존재하는 트리.

>**이진 탐색 트리(Binary Search Tree)**   
: 모든 왼쪽 자식의 값이 루트나 부모보다 작고, 모든 오른쪽 자식의 값이 루트나 부모보다 큰 값을 가잔다.  

이진 탐색 트리는 균형 잡힌 트리가 아닐 때, 입력되는 값의 순서에 따라 한쪽으로 노드들이 몰리게 될 수 있다.  
균형이 잡히지 않은 트리는 탐색하는 데 시간이 걸리는 경우도 있기 때문에 삽입과 삭제마다 트리의 구조를 재조정하는 알고리즘을 추가해서 해결해야 한다.  

-----
## Heap Tree  

일반적인 트리 구조와는 다르게, 우선순위에 따라서 빠르게 자료를 검색할 수 있는 구조.  

### 일상 속 예시  

>응급실에 환자가 들어올 때, 환자가 들어온 순서와 달리 조금 더 빠른 치료가 필요한 환자(우선순위)부터 치료를 시작하는 것.

![](https://velog.velcdn.com/images/wlsk124/post/0696e265-4577-492d-8a16-4abe342a9264/image.png)

heap tree는 느슨한 정렬 구조로 구현되어 있다.

> 
**느슨한 정렬 구조**  
부모 노드의 값은 자식 노드의 값보다 항상 크거나 작게 정렬되어 있다.   
그렇지만 자식 노드끼리의 값의 크기에 따라 좌우 위치가 정렬되지 않기 때문에, 느슨한 정렬 구조라고 표현한다.   

### heap tree의 특징  

**1. 완전 이진 트리**  

완전 이진 트리로 구성되어 있다.  
단순히 최댓값, 최솟값을 찾기 위해서는 완전 이진 트리로 구성할 필요는 없지만,  삽입/삭제 시 성능을 위해 완전 이진 트리로 구현하게 된다.  

**2. 중복된 값 저장**  

일반적인 이진 탐색 트리와 다르게 중복된 값을 저장할 수 있다.   
-> 단순히 최댓값/최솟값을 찾아내기 위한 구조이기 때문.  

**3. 최대 힙 	&#47; 최소 힙**  

heap tree 자료구조는 최대 힙과 최소 힙으로 구현한다.  

📍 최대 힙   
:루트 노드에 가장 큰 값이 위치하며 자식 노드로 내려갈수록 작은 값이 위치.  
📍 최소 힙    
:루트 노드에 가장 작은 값이 위치하며, 자식 노드로 내려갈수록 큰 값이 위치.   

### heap tree의 데이터 처리 방식  

**1. 데이터 검색(최대값 	&#47; 최소값)**  

![](https://velog.velcdn.com/images/wlsk124/post/887b8188-86b3-4617-a54a-6a5ce779eea4/image.png)

**최대 힙일 경우,** 최댓값을 찾는데 걸리는 시간복잡도는 O(1)이다.  
-> 항상 루트 노드의 값이 가장 큰 값이다. (최댓값은 항상 루트 노드의 값)  

**최소 힙일 경우,** 최소값을 찾는데 걸리는 시간복잡도는 O(1)이다.  
-> 항상 루트 노드의 값이 가장 작은 값이다. (최소값은 항상 루트 노드의 값) 

**2. 데이터 삽입**  

![](https://velog.velcdn.com/images/wlsk124/post/1ac8a580-2290-458f-b2a2-aa81f16bd5aa/image.png)

1. 가장 마지막 노드에 새로운 값을 저장한다.
2. 삽입된 노드의 값과 부모 노드의 값을 비교한다.
3. 최대 힙일 경우, 부모의 값이 더 크다면 부모의 값과 위치를 서로 변경한다.
4. 더 이상 위치가 바뀌지 않을 때까지 1~3까지의 과정을 반복한다.  

**3. 데이터 삭제**  

![](https://velog.velcdn.com/images/wlsk124/post/9e6ac652-b25e-420b-8eb9-2c8a90572ee9/image.png)

1. 루트 노드의 값을 제거한다.
2. 루트 자리에 마지막 노드의 값을 삽입한다.
3. 루트 노드의 값과 그 자식 노드들의 값과 비교한다.
4. 부모보다 더 큰 자식이 있다면(최대 힙) 해당 자식의 값과 서로 교환한다.  
 -> 두 자식의 값이 모두 부모보다 작다면, 두 값 중 큰 값과 위치를 변경.  
5. 더 이상 큰 값이 없을 때까지 반복한다.  

### heap tree를 배열로 구현  

![](https://velog.velcdn.com/images/wlsk124/post/1ed473f8-9cf4-435f-9288-ba0d23a07236/image.png)

- heap tree는 완전 이진 트리로 구현되어 배열로 표현할 수 있다.   
- 구현과 노드의 위치를 찾기 쉽게 하기 위해 일반적으로 배열의 0번째 인덱스는 사용하지 않고, 첫 번째 인덱스부터 사용한다.  
- 높이 순서대로 배열에 값을 저장하며, 좌에서 우 순서로 값을 저장한다.  
- 배열로 heap tree를 구현한다면 배열의 크기에 따라서 heap tree의 depth가 얼마인지, 부모와 자식 노드의 위치까지 쉽게 검색할 수 있다.    
- depth(깊이)는 배열의 길이가 1, 3, 7, 15 순서대로 2의 배수를 계속 더한 만큼 depth(깊이)가 늘어난다.  
- 부모와 자식 노드의 인덱스를 찾는 방법도 수식으로 계산할 수 있다.     

### heap tree가 사용되는 곳  

- 우선순위 큐
- 힙 정렬

-----
## Tree traversal  

특정 목적을 위해 트리의 모든 노드를 한 번씩 방문하는 것.  

트리는 계층적 구조의 특징을 가지기 때문에,  
모든 노드를 순회하는 방법은 세 가지가 있다.  
-> 전위 순회, 중위 순회, 후위 순회   

*** 트리 구조에서 노드를 순차적으로 조회할 때 순서는 항상 왼쪽부터 오른쪽이다.**  

### 전위 순회 (preorder traverse)  

![](https://velog.velcdn.com/images/wlsk124/post/d4ea088e-5b76-4c73-ab20-544c57b2d8be/image.gif)

### 중위 순회 (inorder traverse)  

![](https://velog.velcdn.com/images/wlsk124/post/13d7b2e4-12b9-41df-801d-3f2fbd668247/image.gif)

### 후위 순회 (postorder traverse)  

![](https://velog.velcdn.com/images/wlsk124/post/1fa9e6ad-22b5-412b-b133-e8fd228af7b0/image.gif)

-----
## BFS 	&#47; DFS  

그래프의 탐색은 하나의 정점에서 시작하여 그래프의 모든 정점들을 한 번씩 방문(탐색)하는 것이 목적이다.  
그래프의 데이터는 배열처럼 정렬이 되어 있지 않기 때문에 원하는 자료를 찾으려면, 하나씩 모두 방문해서 찾아야 한다.   

그래프의 모든 정점 탐색 방법 중에서 가장 대표적인 두 가지 방법이다.  
BFS, DFS은 데이터를 탐색하는 순서만 다를 뿐, 모든 자료를 하나씩 확인해 본다는 점은 같다.  

### 일상 속 예시  

>한국에서 미국으로 가는 비행기를 예약하려고 한다.  
비행편에 따라 직항과 경유가 있다.  
경유를 하면, 항공사가 필요로 하는 공항에 잠시 머물렀다가 가기도 한다.  
경유하는 시간은 비행편마다 다르고, 경유지도 다르다.  
다양한 여정 중에서, 최단 경로를 알아내려고 한다.  

**BFS(Breadth-First Search)**  

너비를 우선적으로 탐색하는 방법을 Breadth-First Search라고 한다.  
주로 두 정점 사이의 최단 경로를 찾을 때 사용한다.

![](https://velog.velcdn.com/images/wlsk124/post/6b567c24-a314-4dd0-bbfb-12513d58bee6/image.gif)

1. 한국을 기준으로 미국까지 가는 방법을 가까운 정점부터 탐색한다.  
2. 더 탐색할 정점이 없을 때, 다음 떨어져 있는 정점을 순서대로 방문한다.   
3. 직항이라면 어떤 경유지도 없기 때문에 제일 가까운 정점에 미국이 있다.   
4. 경유지가 있다면 직항보다 거리가 멀다는 사실을 확인할 수 있다.    

만약, 경로를 하나씩 전부 방문한다면 최악의 경우 모든 경로를 다 살펴봐야 한다.  

**DFS(Depth-First Search)**  

깊이를 우선적으로 탐색하는 방법을 Depth-First Search라고 한다.  
한 정점에서 다음 경로로 넘어가기 전에 해당 경로를 완벽하게 탐색할 때 사용.

![](https://velog.velcdn.com/images/wlsk124/post/133d46da-9088-4244-8067-9feec5928658/image.gif)

1. 비행기 티켓이 없을 때, 어떤 비행기가 미국으로 가는지 알 수 없다.  
2. 여러 나라를 방문하면서, 마지막에 미국에 도착하는 경로를 찾아야 한다.  
3. DFS는 하나의 경로를 끝까지 탐색한 후, 다음 경로로 넘어가 탐색한다.  
5. 목적지가 아닌걸 체크할 수 있다면, 바로 다음 탐색으로 넘어갈 수 있다.


DFS와 BFS는 모든 정점을 한 번만 방문한다는 공통점을 가지고 있지만, 장단점은 분명하기 때문에 상황에 맞는 탐색 기법을 사용해야 한다.

-----
## Hash Table  

해시함수(hash function)를 사용하여 변환한 해시를 index으로 삼아 key와 데이터(value)를 저장하는 자료구조.  

![](https://velog.velcdn.com/images/wlsk124/post/4befc625-3d84-4cb3-9acd-f349033f8314/image.png)

### 일상 속 예시  

>핸드폰으로 통화를 하기 위해, 단축번호를 설정한다.  
김지나 , 010-1234-5678 , `단축번호 : 1` 저장한다.  
전화를 걸기 위해 미리 저장한 `단축번호 : 1`을 누른다.  
010-1234-5678 번호로 바로 통화를 할 수 있다.  

이 처럼, 필요한 데이터의 키를 해시함수를 사용해 별도의 해시로 바꿔 주고, 해당하는 데이터를 함께 저장하는 자료구조이다.  

### Hash Table의 구조  

hash table은 키, 해시함수, 해시, 데이터로 이루어져 있다.  

**키(key)**   
- 고유한 값으로 해시 함수(hash function)의 입력값.  
- 다양한 길이의 값이 들어올 수 있다.  
- 해시 함수를 통해 변환하지 않은 상태로 저장소에 저장이 되면, 다양한 길이만큼의 저장소를 구성해야 하기 때문에 해시 함수로 값을 바꿔 저장하게 된다.  

**해시함수(hash Function)**  
- 키(key)를 해시(hash)로 바꿔주는 역할.  
- 다양한 길이를 가지고 있는 키를 일정한 길이를 가지는 해시로 변경하여 저장소를 효율적으로 운영할 수 있도록 도와준다.  

다만, 서로 다른 키(key)가 같은 해시(hash)가 되는 경우를 해시 충돌(hash Collision)이라고 하는데, 해시 충돌을 일으키는 확률을 최대한 줄이는 것이 중요하다.  

**해시(hash)**  
- 키(key)를 해시함수(hash function)를 사용하여 만들어진 결과물.  
- 저장소에서 데이터(value)와 매칭되어 저장된다.  
- 변환된 값을 배열의 index와 같이 사용하게 된다.  

**데이터(value)**   
- 저장소에 최종적으로 저장되는 값.  
- 색인(index)과 매칭되어 저장된다.  

### Hash Table의 특징  

**1. 저장, 삭제, 검색 과정**  

값을 저장, 삭제, 검색하기 위해서, 해시 함수에 키값을 넣어 해시값을 만든다.  
이후 만들어진 해시값과 일치하는 index를 찾아 저장하거나 삭제, 검색한다.  

기본적으로 해당 작업들의 시간복잡도는 O(1)이다.  

해시함수를 거쳐 해시값을 찾아내는데 걸리는 과정은 고려하지 않는다.  
그러나 해싱 충돌이 발생할 경우, 저장소의 모든 index(삽입) 혹은 데이터(삭제, 검색)를 찾아봐야 하기 때문에 시간복잡도는 O(n)이 된다.  

**2. 대표적인 해시 알고리즘**  

- Division Method  
: Number type의 키를 저장소의 크기로 나누어 나머지를 index로 사용.  
이때, 저장소의 크기를 소수(Prime Number)로 정하고 2의 제곱수와 먼 값을 사용하는 것이 효과가 좋다.  
예를 들어 Key 값이 23일 때 테이블 크기가 7이라면 index는 2가 됩니다.  

- Digit Folding  
: 키의 문자열을 ASCII 코드로 바꾸고 그 값을 합해 저장소에서 index로 사용.  
만약 이때 index가 저장소의 크기를 넘어간다면 Division Method를 적용할 수 있다.  

- Multiplication Method  
: 숫자로 된 Key 값 K와 0과1 사이의 실수 A, 보통 2의 제곱수인 m을 사용하여 계산한 값을 사용.   
`index = (KA mod 1)m`  

- Universal Hashing  
: 다수의 해시함수를 만들어 특정 장소에 넣어두고, 무작위로 해시함수를 선택해 해시값을 만드는 기법.   

### 해시 충돌을 해결할 수 있는 방법   

>hash table은 해시 충돌이 발생할 수 있고 데이터가 저장되기 전에 저장공간을 미리 만들어놔야 하기 때문에 공간 효율성이 떨어진다.  
또한 해시함수(hash function)의 의존도가 높다.  
-> 해시 함수가 복잡하다면, 해시값을 만드는 데 많은 시간이 소요된다.  

**1. 개방 연결법(Open Addressing)**  

해시 충돌이 발생하면 다른 index에 해당 자료를 삽입하는 방식.  

🍀 **가장 대표적으로 사용되는 3가지 방법** 🍀  

**- Linear Probing**    
현재 중복된 index로 부터, 고정된 숫자만큼 이동하여 비어있는 저장소(bucket)를 찾아 데이터(value)를 저장.  

**- Quadratic Probing**  
현재 중복된 index로 부터 이동할 숫자를 제곱으로 사용하는 방식.  
처음 충돌이 발생하면 `1(1^2)`만큼 이동하고, 또 충돌이 발생하면 `4(2^2)`만큼, 3번째는 `9(3^2)`만큼, 4번째는 `16(4^2)`만큼 이동하여 빈 공간을 탐색하는 방법.  

**- Double Hasing Probing**   
하나의 해시함수에서 충돌이 발생하면 미리 지정해둔 다른 해시함수를 이용해 새로운 주소를 받아 사용하는 방법.  
다른 방법들보다 많은 연산이 필요하다.  

**2. 분리 연결법(Seperate Chaining)**  

분리 연결법이란 동일한 index의 데이터에 대해 연결리스트(linked list), 트리(Red-Black tree) 등의 자료구조를 활용해 데이터의 주소를 저장하는 방법.  

이 경우 구현이 간단하며, 데이터(value)를 쉽게 삭제할 수 있다는 장점이 있다.  
하지만 중복으로 저장되는 데이터가 많아지면 동일한 버킷에 연결된 데이터가 많아져 검색의 효율성이 감소하는 단점이 있다.

**3. 저장소 확장(Resize)**  

저장소에 크기가 작으면, 불필요한 메모리 사용을 줄일 수 있다.  
하지만, 해시 충돌이 발생하며 개방 연결법(Open Addressing)이나 분리 연결법(Separate Chaining)을 사용해도 성능상 손실이 발생한다. 실제 Java에서 사용되는 HashMap은 매치된 key-value 데이터의 개수가 일정 이상이 된다면(저장소의 75% 이상 사용) 저장소의 크기를 두 배로 늘린다.  

이 방식으로 해시 충돌로 인해 성능이 감소하는 문제를 어느 정도 해결할 수 있다.  

### Hash Table 활용 예시  

1. Address Book(주소록)
2. Blockchain(블록체인)
3. 자바스크립트 실행 엔진 (크롬, V8)
4. Domain -> DNS 변환

-----

## 여러 가지 자료 구조에 대해

https://www.freecodecamp.org/news/all-you-need-to-know-about-tree-data-structures-bceacb85490c/

https://www.cs.usfca.edu/~galles/visualization/Algorithms.html
