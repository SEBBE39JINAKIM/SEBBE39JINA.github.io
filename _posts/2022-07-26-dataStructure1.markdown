---
title: "자료구조 기초"
layout: post
date: 2022.07.26
headerImage: false
tag:
- Java
- Concept
- Back-end
category: study
author: Jina Kim
---

## 자료구조의 이해
> **자료구조란?**  
여러 데이터의 묶음을 저장하고, 사용하는 방법을 정의한 것.

### 자료구조의 종류와 구분
![](https://velog.velcdn.com/images/wlsk124/post/35fd15c3-08b9-4d40-8e80-968049ba3376/image.png)

**자주 등장하는 자료구조**  
Stack, Queue, Tree, Graph  

대부분의 자료구조는 특정한 상황에 놓인 문제를 해결하는 데에 특화되어 있다.  
많은 자료구조를 배우면, 빠르고 정확하게 문제를 해결할 수 있다.  
-> 문제 해결력을 필요로 하는 알고리즘 테스트(코딩 테스트)에 필요.  

-----
## Stack

데이터(data)를 순서대로 쌓는 자료구조.  

### 일상생활 속 예시

>설거지를 마친 접시들을 그릇장에 하나씩 쌓아 넣었다.  
다음 날 음식을 담을 그릇이 필요해 그릇장을 열어 그릇을 하나씩 꺼냈다.  
이때, 가장 위에 있는(가장 마지막에 들어간) 그릇을 꺼내 사용했다.  


그릇장 - 자료구조 Stack  
접시 - 데이터(data)

### Stack 특징  

**1. LIFO(Last In First Out), FILO(First In Last Out)**  

먼저 들어간 데이터는 제일 나중에 나오는 후입선출의 구조.  

```java
Stack<Integer> stackExample = new Stack<>();

stackExample.push(1); //data를 넣을 때 push() 사용
stackExample.push(2);
stackExample.push(3);

들어간 순서대로, 1번이 제일 먼저 들어가고 3번이 마지막으로 들어감.

stackExample.pop(); //data를 꺼낼 때 pop() 사용
stackExample.pop();
stackExample.pop();

// 결과값
3, 2, 1
마지막에 있는 데이터부터 차례대로 나온다.
```
**2. 데이터는 하나씩 넣고 뺄 수 있다.**  

데이터가 많이 있어도 하나씩 데이터를 넣고, 뺀다.  
한꺼번에 여러 개를 넣거나 뺄 수 없다.  

**3. 하나의 입출력 방향(제한적 접근)을 가지고 있다.**  

데이터의 입출력 방향이 같다.  

### Stack 활용 예시

![](https://velog.velcdn.com/images/wlsk124/post/7d12ee30-8176-4483-a4eb-a8b4cb3f6e19/image.png)

**웹 브라우저의 뒤로 가기, 앞으로 가기 기능**   

1. 새로운 페이지로 접속할 때, 현재 페이지를 Prev Stack에 보관한다.
2. 이전 페이지로 돌아갈 때에는, 현재 페이지를 Next Stack에 보관하고, Prev Stack에 가장 나중에 보관된 페이지를 현재 페이지로 가져온다.
3. 앞서 방문한 페이지로 이동을 원할 때에는, Next Stack의 가장 마지막으로 보관된 페이지를 가져오고, 현재 페이지를 Prev Stack에 보관한다.

### Stack Method

|Method|설명
|:----:|:----:
| push() | 스택에 데이터 추가.
|pop() | 마지막에 추가된 데이터를 스택에서 삭제하고 삭제한 데이터를 리턴.
|size()| 스택에 추가된 데이터의 크기를 리턴.
|peek()| 가장 나중에 추가된 데이터를 리턴.
|show()| 현재 스택에 포함되어 있는 모든 데이터를 String 타입으로 변환 후 리턴.
|clear()| 현재 스택에 포함되어 있는 모든 데이터를 삭제.
|empty()| 스택의 맨 위에 아무것도 없으면 true, 그렇지 않으면 false를 반환.
|search()| 스택에서 데이터가 있는 인덱스 위치를 반환.(데이터가 없으면 -1 반환)


-----
## Queue

데이터(data)를 차례로 줄세우는 자료구조.

### 일상 속 예시

>마트에서 장을 본 후 계산을 하기 위해 계산대에 줄을 섰다.  
 먼저 온 손님부터 차례로 계산을 하고 나갔다.  
 마지막으로 온 손님은 먼저 도착한 손님이 모두 계산하기 전까지 기다려야 한다.

계산대 - Queue 자료구조  
손님 - 데이터(data)

### Queue 특징

**1. FIFO(First In First Out), LILO(Last In Last Out)**  

먼저 들어간 데이터가 제일 처음에 나오는 선입선출의 구조.
```java
Queue<Integer> queueExample = new LinkedList<>(); 

queueExample.add(1); //data를 넣을 때 add() 사용
queueExample.add(2);
queueExample.add(3);     

들어간 순서대로, 1번이 제일 먼저 들어가고 3번이 마지막으로 들어감.

queueExample.poll(); //data를 꺼낼 때 poll() 사용
queueExample.poll();
queueExample.poll();

//결과값
1, 2, 3
첫 번째에 있는 데이터부터 차례대로 나온다.
```
                                           
**2. 데이터는 하나씩 넣고 뺄 수 있다.**  

데이터가 아무리 많이 있어도 하나씩 데이터를 넣고, 뺀다.   
한꺼번에 여러 개를 넣거나 뺄 수 없다.

**3. 두 개의 입출력 방향을 가지고 있다.**  

데이터의 입력, 출력 방향이 다르다.  
데이터를 넣는 것을 'enqueue', 꺼내는 것을 'dequeue'라고 한다.  

### Queue 활용 예시

![](https://velog.velcdn.com/images/wlsk124/post/b48530a9-bd0f-40b6-a81e-3b0b32b33607/image.png)

**프린터의 인쇄 대기열**  

1. 문서를 작성하고 출력 버튼을 누르면 문서는 인쇄 작업 Queue에 들어간다.
2. 프린터는 인쇄 작업 Queue에 들어온 문서를 순서대로 인쇄한다.

- 여기서 Queue는 임시 기억 장치이다.

**컴퓨터와 프린터 사이의 데이터(data) 통신**  

일반적으로 CPU는 프린터보다 데이터를 처리하는 속도가 빠르다.   
따라서, CPU는 빠른 속도로 인쇄에 필요한 데이터를 만든 다음, Queue에 저장하고 다른 작업을 수행한다.  
프린터는 인쇄 작업 Queue에서 데이터를 받아 일정한 속도로 인쇄한다.   
컴퓨터 장치들 사이에서 데이터를 주고받을 때, 속도의 차이나 시간 차이를 극복하기 위해 임시 기억 장치의 자료구조로 Queue를 사용한다.  

>*** 버퍼(buffer)**  
데이터를 한 곳에서 다른 한 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 메모리의 영역이다.  
*** 버퍼링(buffering)**  
버퍼를 활용하는 방식 또는 버퍼를 채우는 동작을 말한다.   

### Queue Method

|Method| 설명
|:----:|:---:
|add()| 큐에 데이터 추가. 큐가 다 찬 경우 에러 발생
|poll()| 가장 먼저 추가된 데이터를 큐에서 삭제하고 삭제한 데이터를 리턴.
|size()| 큐에 추가된 데이터의 크기를 리턴.
|peek()| 큐에 가장 먼저 추가된 데이터를 리턴.
|show()| 큐에 들어있는 모든 데이터를 String 타입으로 변환 후 리턴.
|clear()| 큐에 들어있는 모든 데이터를 삭제.
|offer()| 큐에 데이터 추가. 추가 실패시 false를 반환.
|element()| 큐에 가장 먼저 추가된 데이터를 리턴. 대기열이 비어 있는 경우 예외 발생.
|remove()| 큐의 가장 먼저 추가된 데이터를 반환하고 제거. 대기열이 비어 있는 경우 예외 발생.

-----
## Tree

단방향 그래프의 한 구조로, 하나의 뿌리로부터 가지가 뻗어있는 자료구조.   

하나의 데이터 아래에 여러 개의 데이터가 존재할 수 있는 비선형 구조.    
트리 구조는 계층적으로 표현 되고, 아래로만 뻗어나가기 때문에 사이클이 없다.   

### Tree 특징

![](https://velog.velcdn.com/images/wlsk124/post/b6a6b16f-08e3-4484-8616-7a9764553806/image.png)

>**용어정리**  
Node: 트리 구조를 이루는 모든 개별 데이터   
Root: 트리 구조의 시작점이 되는 노드   
Parent node: 상하관계로 연결 된 두 노드 중, 루트에서 가까운 노드   
Child node: 상하관계로 연결 된 두 노드 중, 루트에서 먼 노드   
Leaf: 트리 구조의 끝 지점이고, 자식 노드가 없는 노드   
Sibling Node: 같은 레벨에 나란히 있는 노드   

하나의 Root를 시작으로 여러 개의 데이터를 간선(edge)으로 연결한다.   
각 데이터를 Node라고 하며, 두 노드가 상하 계층으로 연결되면 부모/자식 관계를 가진다.   
- A는 B와 C의 `Parent Node`이고, B와 C는 A의 `Child Node`이다.    

자식이 없는 노드는 나무의 잎과 같다고 하여 `Leaf Node`라고 부른다.    

![](https://velog.velcdn.com/images/wlsk124/post/7c8df605-9dde-4b8b-b791-254bd18f19ad/image.png)

**깊이(depth)**   
트리 구조에서는 루트에서 부터 하위 계층의 특정 노드까지의 깊이를 표현.   
루트 노드는 지면에 있는 것처럼 깊이가 0이다.   
루트 A의 깊이는 0이고, B와 C는 1이다. D, E, F, G의 깊이는 2다.   

**레벨(Level)**   
트리 구조에서 같은 깊이를 가지고 있는 노드를 묶어서 레벨로 표현.   
깊이가 0인 루트 A는 level 1, 깊이가 1인 B, C는 level 2, 깊이가 2인 D, E, F, G는 level 3이다.   

**높이(Height)**   
트리 구조에서 리프 노드를 기준으로 루트까지의 높이를 표현.   
리프 노드와 직간접적으로 연결된 노드의 높이를 표현하며, 부모 노드는 자식 노드의 가장 높은 높이에 1을 더한 값을 높이로 가진다. 높이를 표현할 때, 각 리프 노드의 높이는 0이다.   
H, I, E, F, J의 높이는 0. D, G의 높이는 1. B, C의 높이는 2이다. 이때 B는 D의 `height + 1`을, C는 G의 `height + 1`을 높이로 가진다. 따라서, 루트 A의 높이는 3이다.  

**서브 트리(Sub tree)**   
트리 구조의 루트에서 뻗어 나오는 큰 트리의 내부에, 트리 구조를 갖춘 작은 트리를 서브 트리라고 한다.   
(D, H, I), (B, D, E), (C, F, G, J)를 서브 트리라고 한다.  

### Tree 활용 예시

![](https://velog.velcdn.com/images/wlsk124/post/7e644000-7582-4469-b946-9bbbbcc6cefd/image.png)

**컴퓨터의 디렉토리 구조**   
1. 프로그램이나 파일을 찾을 때, 바탕화면이나 다운로드 폴더에서 다른 폴더에 진입한다.   
2. 그 안에서 다른 폴더에 진입하면서 원하는 프로그램이나 파일을 찾는다.   

모든 폴더는 하나의 폴더(루트 폴더, /)에서 시작되어, 가지를 뻗어나가는 모양새를 띈다.  

하나의 폴더 안에 여러 개의 폴더가 있고, 또 그 여러 개의 폴더 안에 또 다른 폴더나 파일이 있다. 첫 번째 폴더(Root)에서 도착하려는 폴더로 가는 경로는 유일하다.   

-----
## Grape

여러개의 점들이 서로 복잡하게 연결되어 있는 관계를 표현한 자료구조.   
컴퓨터 공학에서의 그래프 자료구조는 복잡한 네트워크망과 같은 모습이다.   

### 일상 속 예시

>서울에 사는 A는 부산에 사는 B의 결혼식에 참석하기로 했다.    
A는 대전에 살고 있는 C와 힘께 B의 결혼식에 참석하려고 한다.   
A는 서울에서 출발해 대전에서 C를 태워 부산으로 이동하려고 한다.  

정점: 서울, 대전, 부산    
간선: 서울—대전, 대전—부산, 부산—서울    

### Grape 특징

![](https://velog.velcdn.com/images/wlsk124/post/a639df03-5893-4de9-91bc-2d62eae364bb/image.png)

>**용어정리**  
정점(vertex): 노드라고도 하며 데이터가 저장되는 그래프의 기본 원소  
간선(edge): 정점 간의 관계를 나타내는 정점을 이어주는 선  
인접 정점(adjacent vertex): 하나의 정점에서 직접 연결되어 있는 정점     
가중치 그래프(weighted Graph): 연결의 강도가 적혀져 있는 그래프   
비가중치 그래프(unweighted Graph): 연결의 강도가 안 적힌 그래프   
무(방)향 그래프(undirected graph): 방향이 없는 간선 그래프   
진입차수(in-degree): 한 정점에 진입(들어오는 간선)하는 간선의 수   
진출차수(out-degree): 한 정점에 진출(나가는 간선)하는 간선의 수   
인접(adjacency): 간선이 직접 이어진 두 정점(인접한 정점)   
자기 루프(self loop): 다른 정점을 안 거치고 바로 자기 자신에게 진입   
사이클(cycle): 한 정점에서 출발하여 다시 해당 정점으로 돌아가는 경우   


직접적인 관계인 경우, 두 점 사이를 이어주는 선이 있다.   
간접적인 관계인 경우, 몇 개의 점과 선에 걸쳐 이어진다.   

하나의 점을 그래프에서는 정점(vertex)이라고 표현하고, 하나의 선은 간선(edge)이라고 한다. 간선에 방향이 한쪽으로만 존재하면 단방향 간선이라고 하고, 양쪽으로 존재하면 양방향 간선이라고 한다.   

### Graph의 표현 방식

**인접 행렬**  

서로 다른 정점들이 인접한 상태인지를 표시한 행렬로 2차원 배열의 형태로 나타낸다. 이어져 있다면 1(true), 이어져 있지 않다면 0(false)으로 표시.  
가장 빠른 경로(shortest path)를 찾을 때 주로 사용된다.  

만약 가중치 그래프라면 1 대신 관계에서 의미 있는 값을 저장한다.   

**인접 리스트**  

각 정점이 어떤 정점과 인접하는지를 리스트의 형태로 표현한다. 각 정점마다 하나의 리스트를 가지고 있으며, 이 리스트는 자신과 인접한 다른 정점을 담고 있다.   
인접 행렬은 연결 가능한 모든 경우의 수를 저장해서 상대적으로 메모리를 많이 차지하기 때문에 메모리를 효율적으로 사용하고 싶을 때 인접 리스트를 사용한다.   

![](https://velog.velcdn.com/images/wlsk124/post/dfb901e7-d3af-46e8-b0c2-4850caf7e5bb/image.png)

C는 A와 B로 이어지는 간선이 두 개가 있지만 보통 순서는 중요하지 않다.   

### Graph 활용 예시

**내비게이션 시스템**   
1. 각 도시를 정점이라고 할 경우, 내비게이션에 경유하는 곳을 입력한다.    
2. 경유지(대전)을 지나 부산으로 갈 경우를 가중치 그래프로 표현한다.   
3. 표현한 그래프를 내비게이션에 적용하여 사용자에게 보여준다.   

정점: 서울, 대전, 부산   
간선: 서울—140km—대전, 대전—200km—부산, 부산—325km—서울   
